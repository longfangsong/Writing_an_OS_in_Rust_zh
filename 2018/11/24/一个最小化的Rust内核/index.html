<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="一个最小化的Rust内核在这篇文章中，我们为x86架构创建了一个最小化的64位Rust内核。 我们基于上一篇文章中的独立Rust二进制文件构建了一个可引导的磁盘映像，它可以将某些内容打印到屏幕上。 这个博客所描述的内核已经公开在Github上。 如果您有任何问题或疑问，请在那里开一个issue。 您也可以在原作者博客的底部留言。 启动过程当您打开计算机时，它开始执行存储在主板ROM中的固件代码。">
<meta name="keywords" content="Bare Bones">
<meta property="og:type" content="article">
<meta property="og:title" content="一个最小化的Rust内核">
<meta property="og:url" content="https://longfangsong.github.io/2018/11/24/一个最小化的Rust内核/index.html">
<meta property="og:site_name" content="用Rust编写一个操作系统">
<meta property="og:description" content="一个最小化的Rust内核在这篇文章中，我们为x86架构创建了一个最小化的64位Rust内核。 我们基于上一篇文章中的独立Rust二进制文件构建了一个可引导的磁盘映像，它可以将某些内容打印到屏幕上。 这个博客所描述的内核已经公开在Github上。 如果您有任何问题或疑问，请在那里开一个issue。 您也可以在原作者博客的底部留言。 启动过程当您打开计算机时，它开始执行存储在主板ROM中的固件代码。">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/6/6d/Codepage-737.png">
<meta property="og:image" content="https://os.phil-opp.com/minimal-rust-kernel/qemu.png">
<meta property="og:updated_time" content="2018-11-24T14:09:18.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="一个最小化的Rust内核">
<meta name="twitter:description" content="一个最小化的Rust内核在这篇文章中，我们为x86架构创建了一个最小化的64位Rust内核。 我们基于上一篇文章中的独立Rust二进制文件构建了一个可引导的磁盘映像，它可以将某些内容打印到屏幕上。 这个博客所描述的内核已经公开在Github上。 如果您有任何问题或疑问，请在那里开一个issue。 您也可以在原作者博客的底部留言。 启动过程当您打开计算机时，它开始执行存储在主板ROM中的固件代码。">
<meta name="twitter:image" content="https://upload.wikimedia.org/wikipedia/commons/6/6d/Codepage-737.png">
    
    
        
          
              <link rel="shortcut icon" href="/Writing_an_OS_in_Rust_zh/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/Writing_an_OS_in_Rust_zh/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/Writing_an_OS_in_Rust_zh/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>一个最小化的Rust内核</title>
    <!-- styles -->
    <link rel="stylesheet" href="/Writing_an_OS_in_Rust_zh/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/Writing_an_OS_in_Rust_zh/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/Writing_an_OS_in_Rust_zh/">Home</a></li>
         
          <li><a href="/Writing_an_OS_in_Rust_zh/about/">About</a></li>
         
          <li><a href="/Writing_an_OS_in_Rust_zh/archives/">Writing</a></li>
         
          <li><a href="/Writing_an_OS_in_Rust_zh/projects_url">Projects</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/Writing_an_OS_in_Rust_zh/2019/01/31/介绍分页/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/Writing_an_OS_in_Rust_zh/2018/02/10/一个独立的Rust可执行二进制文件/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://longfangsong.github.io/2018/11/24/一个最小化的Rust内核/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://longfangsong.github.io/2018/11/24/一个最小化的Rust内核/&text=一个最小化的Rust内核"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://longfangsong.github.io/2018/11/24/一个最小化的Rust内核/&title=一个最小化的Rust内核"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://longfangsong.github.io/2018/11/24/一个最小化的Rust内核/&is_video=false&description=一个最小化的Rust内核"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=一个最小化的Rust内核&body=Check out this article: https://longfangsong.github.io/2018/11/24/一个最小化的Rust内核/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://longfangsong.github.io/2018/11/24/一个最小化的Rust内核/&title=一个最小化的Rust内核"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://longfangsong.github.io/2018/11/24/一个最小化的Rust内核/&title=一个最小化的Rust内核"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://longfangsong.github.io/2018/11/24/一个最小化的Rust内核/&title=一个最小化的Rust内核"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://longfangsong.github.io/2018/11/24/一个最小化的Rust内核/&title=一个最小化的Rust内核"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://longfangsong.github.io/2018/11/24/一个最小化的Rust内核/&name=一个最小化的Rust内核&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一个最小化的Rust内核"><span class="toc-number">1.</span> <span class="toc-text">一个最小化的Rust内核</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#启动过程"><span class="toc-number">1.1.</span> <span class="toc-text">启动过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#多启动标准"><span class="toc-number">1.1.1.</span> <span class="toc-text">多启动标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UEFI"><span class="toc-number">1.1.2.</span> <span class="toc-text">UEFI</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最小化内核"><span class="toc-number">1.2.</span> <span class="toc-text">最小化内核</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#目标定义"><span class="toc-number">1.2.1.</span> <span class="toc-text">目标定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#现在把它们放在一起"><span class="toc-number">1.2.2.</span> <span class="toc-text">现在把它们放在一起</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构建我们的内核"><span class="toc-number">1.3.</span> <span class="toc-text">构建我们的内核</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cargo-xbuild"><span class="toc-number">1.3.1.</span> <span class="toc-text">Cargo xbuild</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#输出到屏幕"><span class="toc-number">1.4.</span> <span class="toc-text">输出到屏幕</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建一个可引导的磁盘映像"><span class="toc-number">1.5.</span> <span class="toc-text">创建一个可引导的磁盘映像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#它是怎么工作的"><span class="toc-number">1.5.1.</span> <span class="toc-text">它是怎么工作的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bootimage配置"><span class="toc-number">1.5.2.</span> <span class="toc-text">Bootimage配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#启动！"><span class="toc-number">1.6.</span> <span class="toc-text">启动！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#真机"><span class="toc-number">1.7.</span> <span class="toc-text">真机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接下来？"><span class="toc-number">1.8.</span> <span class="toc-text">接下来？</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope="" itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        一个最小化的Rust内核
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
        <span itemprop="name">用Rust编写一个操作系统</span>
      </span>
      
    <div class="postdate">
        <time datetime="2018-11-24T11:12:16.000Z" itemprop="datePublished">2018-11-24</time>
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/Writing_an_OS_in_Rust_zh/tags/Bare-Bones/">Bare Bones</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="一个最小化的Rust内核"><a href="#一个最小化的Rust内核" class="headerlink" title="一个最小化的Rust内核"></a>一个最小化的Rust内核</h1><p>在这篇文章中，我们为x86架构创建了一个最小化的64位Rust内核。 我们基于上一篇文章中的独立Rust二进制文件构建了一个可引导的磁盘映像，它可以将某些内容打印到屏幕上。</p>
<p>这个博客所描述的内核已经公开在<a href="https://github.com/phil-opp/blog_os" target="_blank" rel="noopener">Github</a>上。 如果您有任何问题或疑问，请在那里开一个issue。 您也可以在原作者博客的底部留言。</p>
<h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><p>当您打开计算机时，它开始执行存储在主板ROM中的固件代码。 这些代码执行开机自检，检测可用RAM，并预初始化CPU和硬件。 然后，它会查找可引导磁盘并开始引导操作系统内核。</p>
<p>在x86上，有两种固件标准：“基本输入/输出系统”（BIOS）和较新的“统一可扩展固件接口”（UEFI）。 自20世纪80年代以来，BIOS标准已经陈旧且过时，但在任何x86机器上都很简单且得到很好的支持。 相比之下，UEFI更现代，功能更多，但设置起来更复杂（至少在我看来）。</p>
<p>目前，我们只提供BIOS支持，但也计划支持UEFI。 如果您想帮助我们，请查看Github issues。</p>
<p>几乎所有x86系统都支持从BIOS启动，包括使用模拟BIOS的基于UEFI的新机器。这很棒，因为您可以在从上个世纪起至今的所有机器上使用相同的启动逻辑。但是这种广泛的兼容性同时也是BIOS启动的最大缺点，因为它意味着CPU在启动之前被置于一种称为实模式的16位兼容模式，因此20世纪80年代的古老引导加载程序仍然可以工作。</p>
<p>但是，让我们从头开始：</p>
<p>当您打开计算机时，它会从主板上的某些特别的ROM中加载BIOS。 BIOS运行硬件的自检和初始化程序，然后查找可引导磁盘。如果找到一个，则跳转到其引导加载程序，该引导加载程序是存储在磁盘开头的512字节的可执行代码。大多数引导加载程序大于512字节，因此引导加载程序通常分为小的第一级（512字节以内）和第二级（由第一级加载）。</p>
<p>引导加载程序必须确定磁盘上内核映像的位置并将其加载到内存中。它还需要将CPU从16位实模式首先切换到32位保护模式，然后再切换到64位长模式，来使64位寄存器和整个主存储器可用。它的第三个任务是从BIOS查询某些信息（例如内存映射）并将其传递给OS内核。</p>
<p>编写引导加载程序有点麻烦，因为这需要汇编语言和许多不太讲道理的步骤，例如“将这个魔数写到这个寄存器里”。因此，我们不会在本文中介绍引导加载程序的创建，而是提供一个名为bootimage的工具，该工具会自动将引导加载程序添加到内核中。</p>
<p>如果您有兴趣构建自己的引导加载程序：请继续关注这个博客，关于此主题的一组帖子已经在计划中了！</p>
<h3 id="多启动标准"><a href="#多启动标准" class="headerlink" title="多启动标准"></a>多启动标准</h3><p>为了避免每个操作系统都实现自己的（仅与这一个操作系统兼容的）引导加载程序，自由软件基金会在1995年创建了一个名为Multiboot的开放引导加载程序标准。该标准定义了引导加载程序和操作系统之间的接口，以便任何多重引导兼容的引导加载程序可以加载任何符合Multiboot的操作系统。参考实现是GNU GRUB，它是Linux系统中最流行的引导加载程序。</p>
<p>要使内核与Multiboot兼容，只需在内核文件的开头插入一个所谓的Multiboot头。这使得在GRUB中启动OS非常容易。但是，GRUB和Multiboot标准也存在一些问题：</p>
<p>它们仅支持32位保护模式。这意味着您仍然必须执行CPU配置以切换到64位长模式。<br>它们旨在使引导加载程序简单而不是内核。例如，内核需要与调整后的默认页面大小链接，因为否则GRUB无法找到Multiboot标头。另一个例子是传递给内核的引导信息包含许多与体系结构相关的结构，而不是干净的抽象。</p>
<p>GRUB和Multiboot的文档都很匮乏。</p>
<p>需要在主机系统上安装GRUB以从内核文件创建可引导的磁盘映像。这使得在Windows或Mac上的开发更加困难。</p>
<p>由于这些缺点，我们决定不使用GRUB或Multiboot标准。但是，我们计划在我们的bootimage工具中添加Multiboot支持，这样就可以在GRUB系统上加载内核。如果您对编写符合Multiboot的内核感兴趣，请查看本博客系列的第一版。</p>
<h3 id="UEFI"><a href="#UEFI" class="headerlink" title="UEFI"></a>UEFI</h3><p>（我们目前不提供UEFI支持，但我们很乐意这样做！如果您想提供帮助，请在Github issues中告诉我们。）</p>
<h2 id="最小化内核"><a href="#最小化内核" class="headerlink" title="最小化内核"></a>最小化内核</h2><p>现在我们大致知道计算机是如何启动的了，现在是时候创建我们自己的最小化内核了。 我们的目标是创建一个磁盘映像，在启动时将“Hello World!”打印到屏幕上。 为此，我们在上一篇文章中建立了独立的Rust二进制文件。</p>
<p>您可能还记得，我们通过cargo构建了独立的二进制文件，但根据操作系统的不同，我们需要使用不同的入口点名称和编译选项。 这是因为默认情况下cargo为有操作系统的环境构建，即为您正在运行的系统构建。 我们想要的内核不是这样，因为一个内核运行在一个操作系统，例如Windows，上没有多大意义。 相反地，我们想要为明确定义的目标系统进行编译。</p>
<h3 id="目标定义"><a href="#目标定义" class="headerlink" title="目标定义"></a>目标定义</h3><p>cargo通过<code>--target</code>参数支持不同的目标系统。 目标由所谓的目标三元组描述，其描述了CPU架构，供应商，操作系统和ABI。 例如，<code>x86_64-unknown-linux-gnu</code>目标三元组描述的系统具有x86_64 CPU，没有明确的供应商和具有GNU ABI的Linux操作系统。 Rust支持许多不同的目标三元组，包括用于Android的<code>arm-linux-androideabi</code>或用于WebAssembly的<code>wasm32-unknown-unknown</code>。</p>
<p>但是，对于我们的目标系统，我们需要一些特殊的配置参数（例如，没有底层操作系统），因此现有的目标三元组都不适合。 幸运的是，Rust允许我们通过JSON文件定义自己的目标。 例如，描述<code>x86_64-unknown-linux-gnu</code>目标的JSON文件如下所示：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"llvm-target"</span>: <span class="string">"x86_64-unknown-linux-gnu"</span>,</span><br><span class="line">    <span class="attr">"data-layout"</span>: <span class="string">"e-m:e-i64:64-f80:128-n8:16:32:64-S128"</span>,</span><br><span class="line">    <span class="attr">"arch"</span>: <span class="string">"x86_64"</span>,</span><br><span class="line">    <span class="attr">"target-endian"</span>: <span class="string">"little"</span>,</span><br><span class="line">    <span class="attr">"target-pointer-width"</span>: <span class="string">"64"</span>,</span><br><span class="line">    <span class="attr">"target-c-int-width"</span>: <span class="string">"32"</span>,</span><br><span class="line">    <span class="attr">"os"</span>: <span class="string">"linux"</span>,</span><br><span class="line">    <span class="attr">"executables"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"linker-flavor"</span>: <span class="string">"gcc"</span>,</span><br><span class="line">    <span class="attr">"pre-link-args"</span>: [<span class="string">"-m64"</span>],</span><br><span class="line">    <span class="attr">"morestack"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大多数字段是为了让LLVM为该平台生成代码的。 例如，<code>data-layout</code>字段定义了各种整数，浮点和指针类型的大小。 然后有Rust用于条件编译的字段，例如<code>target-pointer-width</code>。 第三种字段定义了如何构建crate。 例如，<code>pre-link-args</code>字段指定传递给链接器的参数。</p>
<p>我们的内核目标位x86_64系统，因此我们的目标定义看起来与上面的非常类似。 让我们首先创建一个<code>x86_64-blog_os.json</code>文件（你也可以选择您喜欢的任何名称）：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"llvm-target"</span>: <span class="string">"x86_64-unknown-none"</span>,</span><br><span class="line">    <span class="attr">"data-layout"</span>: <span class="string">"e-m:e-i64:64-f80:128-n8:16:32:64-S128"</span>,</span><br><span class="line">    <span class="attr">"arch"</span>: <span class="string">"x86_64"</span>,</span><br><span class="line">    <span class="attr">"target-endian"</span>: <span class="string">"little"</span>,</span><br><span class="line">    <span class="attr">"target-pointer-width"</span>: <span class="string">"64"</span>,</span><br><span class="line">    <span class="attr">"target-c-int-width"</span>: <span class="string">"32"</span>,</span><br><span class="line">    <span class="attr">"os"</span>: <span class="string">"none"</span>,</span><br><span class="line">    <span class="attr">"executables"</span>: <span class="literal">true</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，我们将<code>llvm-target</code>和<code>os</code>字段中的操作系统更改为<code>none</code>，因为我们将在裸机上运行。</p>
<p>我们添加以下与构建相关的字段：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">"linker-flavor": "ld.lld",</span><br><span class="line">"linker": "rust-lld",</span><br></pre></td></tr></table></figure>
<p>我们使用Rust附带的跨平台LLD链接器来链接我们的内核，而不是使用平台默认的链接器（可能不支持Linux目标）。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"panic-strategy": "abort",</span><br></pre></td></tr></table></figure>
<p>此设置指定目标在<code>panic</code>时不进行堆栈解退，而是直接中止。 这与我们的<code>Cargo.toml</code>中的<code>panic = &quot;abort&quot;</code>选项具有相同的效果，因此我们可以删除那里的<code>panic = &quot;abort&quot;</code>。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"disable-redzone": true,</span><br></pre></td></tr></table></figure>
<p>我们正在编写内核，因此我们需要在某些时候处理中断。 为了安全地执行此操作，我们必须禁用称为“红色区域”的特定堆栈指针优化，否则会导致堆栈损坏。 有关更多信息，请参阅有关禁用红色区域的单独帖子。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"features": "-mmx,-sse,+soft-float",</span><br></pre></td></tr></table></figure>
<p>features字段启用/禁用目标的功能。 我们通过在前面添加减号来禁用mmx和sse功能，并通过在前面添加加号来启用软浮点功能。</p>
<p>mmx和sse功能决定了对单指令多数据（SIMD）指令的支持，这通常可以显着加快程序的速度。 但是，大型SIMD寄存器会导致操作系统内核出现性能问题，因为内核必须在每个硬件中断上备份它们。 为了避免这种情况，我们为内核禁用了SIMD（不适用于运行在其上的应用程序！）。</p>
<p>禁用SIMD带来的一个问题是x86_64上的浮点运算默认需要SIMD寄存器。 为了解决这个问题，我们添加了soft-float功能，它通过软件模拟所有浮点运算。</p>
<p>有关更多信息，请参阅有关禁用SIMD的帖子。</p>
<h3 id="现在把它们放在一起"><a href="#现在把它们放在一起" class="headerlink" title="现在把它们放在一起"></a>现在把它们放在一起</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"llvm-target"</span>: <span class="string">"x86_64-unknown-none"</span>,</span><br><span class="line">  <span class="attr">"data-layout"</span>: <span class="string">"e-m:e-i64:64-f80:128-n8:16:32:64-S128"</span>,</span><br><span class="line">  <span class="attr">"arch"</span>: <span class="string">"x86_64"</span>,</span><br><span class="line">  <span class="attr">"target-endian"</span>: <span class="string">"little"</span>,</span><br><span class="line">  <span class="attr">"target-pointer-width"</span>: <span class="string">"64"</span>,</span><br><span class="line">  <span class="attr">"target-c-int-width"</span>: <span class="string">"32"</span>,</span><br><span class="line">  <span class="attr">"os"</span>: <span class="string">"none"</span>,</span><br><span class="line">  <span class="attr">"executables"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"linker-flavor"</span>: <span class="string">"ld.lld"</span>,</span><br><span class="line">  <span class="attr">"linker"</span>: <span class="string">"rust-lld"</span>,</span><br><span class="line">  <span class="attr">"panic-strategy"</span>: <span class="string">"abort"</span>,</span><br><span class="line">  <span class="attr">"disable-redzone"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"features"</span>: <span class="string">"-mmx,-sse,+soft-float"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="构建我们的内核"><a href="#构建我们的内核" class="headerlink" title="构建我们的内核"></a>构建我们的内核</h2><p>我们的新目标将使用Linux约定来编译（我不太清楚为什么，我认为它是LLVM的默认值）。 这意味着我们需要一个名为<code>_start</code>的入口点，如上一篇文章所述：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#![no_std]</span> <span class="comment">// don't link the Rust standard library</span></span><br><span class="line"><span class="meta">#![no_main]</span> <span class="comment">// disable all Rust-level entry points</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> core::panic::PanicInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// This function is called on panic.</span></span><br><span class="line"><span class="meta">#[panic_handler]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">panic</span></span>(_info: &amp;PanicInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span> <span class="comment">// don't mangle the name of this function</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() -&gt; ! &#123;</span><br><span class="line">    <span class="comment">// this function is the entry point, since the linker looks for a function</span></span><br><span class="line">    <span class="comment">// named `_start` by default</span></span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，无论您的主机操作系统如何，都需要将入口点称为<code>_start</code>。 你应该删除上一篇文章中介绍的Windows和macOS入口点。</p>
<p>我们现在可以通过将JSON文件的名称作为<code>--target</code>参数传递来以我们的新目标构建内核：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> cargo build --target x86_64-blog_os.json</span></span><br><span class="line"></span><br><span class="line">error[E0463]: can't find crate for `core` OR</span><br><span class="line">error[E0463]: can't find crate for `compiler_builtins`</span><br></pre></td></tr></table></figure>
<p>它炸了…… 该错误告诉我们Rust编译器找不到<code>core</code>或<code>compiler_builtins</code>库。 两个库都隐式链接到所有<code>no_std</code>包。 <code>core</code>包含基本的Rust类型，如<code>Result</code>，<code>Option</code>和迭代器类型，而<code>compiler_builtins</code>库提供LLVM需要的各种底层函数，例如<code>memcpy</code>。</p>
<p>问题是<code>core</code>库与Rust编译器一起作为预编译库分发。 因此它仅对受支持的主机三元组（例如<code>x86_64-unknown-linux-gnu</code>）有效，但不适用于我们的自定义目标。 如果我们想为其他目标编译代码，我们需要首先为这些目标重新编译<code>core</code>。</p>
<h3 id="Cargo-xbuild"><a href="#Cargo-xbuild" class="headerlink" title="Cargo xbuild"></a>Cargo xbuild</h3><p>这就是<code>cargo xbuild</code>的用武之地了。它是<code>cargo</code>的一层包装，可以自动交叉编译核心和其他内置库。 我们可以通过执行下面的命令来安装它：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install cargo-xbuild</span><br></pre></td></tr></table></figure>
<p>该命令取决于Rust源代码，我们可以使用<code>rustup</code>组件添加<code>rust-src</code>来安装。</p>
<p>现在我们可以用<code>xbuild</code>而不是<code>build</code>重新运行上面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> cargo xbuild --target x86_64-blog_os.json</span></span><br><span class="line">   Compiling core v0.0.0 (file:///…/rust/src/libcore)</span><br><span class="line">    Finished release [optimized] target(s) in 52.75 secs</span><br><span class="line">   Compiling compiler_builtins v0.1.0 (file:///…/rust/src/libcompiler_builtins)</span><br><span class="line">    Finished release [optimized] target(s) in 3.92 secs</span><br><span class="line">   Compiling alloc v0.0.0 (/tmp/xargo.9I97eR3uQ3Cq)</span><br><span class="line">    Finished release [optimized] target(s) in 7.61s</span><br><span class="line">   Compiling blog_os v0.1.0 (file:///…/blog_os)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.29 secs</span><br></pre></td></tr></table></figure>
<p>我们看到<code>cargo xbuild</code>为我们的新自定义目标交叉编译了<code>core</code>，<code>compiler_builtin</code>和<code>alloc</code>库。 由于这些库在内部使用了许多不稳定的功能，因此这仅适用于nightly版本的Rust编译器。 最终，<code>cargo xbuild</code>成功编译了我们的blog_os crate。</p>
<p>现在我们可以为裸机目标构建内核。 但是，我们的<code>_start</code>入口点（将由引导加载程序调用）仍为空。 所以让我们在这里输出一些内容。</p>
<h2 id="输出到屏幕"><a href="#输出到屏幕" class="headerlink" title="输出到屏幕"></a>输出到屏幕</h2><p>现阶段将文本打印到屏幕的最简单方法是使用VGA文本缓冲区。 它是映射到VGA硬件的一块特殊存储区，包含屏幕上显示的内容。 它通常由25行组成，每行包含80个字符单元格。 每个字符单元格显示带有一些前景色和背景色的ASCII字符。 屏幕输出如下所示：</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/6/6d/Codepage-737.png" alt="vga_image"></p>
<p>我们将在下一篇文章中讨论VGA缓冲区的确切布局，我们为此编写第一个小驱动程序。 对于打印“Hello World!”，我们只需要知道VGA缓冲区位于地址<code>0xb8000</code>，并且每个字符单元由ASCII字节和颜色字节组成。</p>
<p>实现方式看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> HELLO: &amp;[<span class="built_in">u8</span>] = <span class="string">b"Hello World!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>() -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">let</span> vga_buffer = <span class="number">0xb8000</span> <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">u8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, &amp;byte) <span class="keyword">in</span> HELLO.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">unsafe</span> &#123;</span><br><span class="line">            *vga_buffer.offset(i <span class="keyword">as</span> <span class="built_in">isize</span> * <span class="number">2</span>) = byte;</span><br><span class="line">            *vga_buffer.offset(i <span class="keyword">as</span> <span class="built_in">isize</span> * <span class="number">2</span> + <span class="number">1</span>) = <span class="number">0xb</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们将整数<code>0xb8000</code>转换为裸指针。然后我们遍历静态字节字符串HELLO的每个字节。我们使用<code>enumerate</code>方法来另外获取索引变量<code>i</code>。在for循环的主体中，我们使用offset方法写入字符串字节和相应的颜色字节（<code>0xb</code>是浅青色）。</p>
<p>请注意，所有内存写入都要写在<code>unsafe</code>块中。原因是Rust编译器无法证明我们创建的原始指针是有效的。他们可以指向任何地方并导致数据损坏。通过将它们放入<code>unsafe</code>的块中，我们向编译器保证我们绝对确定操作是有效的。请注意，<code>unsafe</code>块不会关闭Rust的安全检查。它只<a href="https://doc.rust-lang.org/stable/book/second-edition/ch19-01-unsafe-rust.html#unsafe-superpowers" target="_blank" rel="noopener">多允许你做四件事</a>。</p>
<p>我想强调，这不是<strong>我们想要的在Rust中做事的方式</strong>！在<code>unsafe</code>块中使用裸指针时很容易搞砸，例如，如果我们不够小心，我们可以轻松地在缓冲区之外进行写入。</p>
<p>因此，我们希望尽可能减少<code>unsafe</code>的使用。 Rust使我们能够通过创建安全的抽象来实现这一目标。例如，我们可以创建一个VGA缓冲区类型，封装所有不安全的内容，并确保不可能从外部做任何错误。这样，我们只需要极少量的不安全因素，并确保我们不会违反内存安全性。我们将在下一篇文章中创建这样一个安全的VGA缓冲区抽象。</p>
<h2 id="创建一个可引导的磁盘映像"><a href="#创建一个可引导的磁盘映像" class="headerlink" title="创建一个可引导的磁盘映像"></a>创建一个可引导的磁盘映像</h2><p>现在我们有了一个真的可以干点什么的可执行文件，是时候把它变成可引导的磁盘映像了。 正如我们在关于引导的部分中所学到的，我们需要一个引导加载程序，它初始化CPU并加载我们的内核。</p>
<p>我们使用<code>bootloader</code>包，而不是自己编写我们自己的引导加载程序，这个<code>crate</code>是一个独立的项目。 它实现了一个基本的BIOS引导加载程序，只用了<code>Rust</code>和内联汇编，而没有任何对C的依赖。 要使用它来引导我们的内核，我们需要添加一个依赖项：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in Cargo.toml</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">bootloader</span> = <span class="string">"0.3.4"</span></span><br></pre></td></tr></table></figure>
<p>将引导加载程序添加为依赖项并不足以实际创建可引导的磁盘映像。 问题是我们需要在编译后将引导加载程序与内核结合起来，但是在成功编译之后<code>cargo</code>不支持额外的构建步骤（有关更多信息，请参阅<a href="https://github.com/rust-lang/cargo/issues/545" target="_blank" rel="noopener">此issue</a>）。</p>
<p>为了解决这个问题，我们创建了一个名为<code>bootimage</code>的工具，它首先编译内核和引导程序，然后将它们组合在一起以创建可引导的磁盘映像。 要安装该工具，请在终端中执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo install bootimage --version "^0.5.0"</span><br></pre></td></tr></table></figure>
<p><code>^0.5.0</code>是所谓的<code>caret</code>要求，表示“版本0.5.0或更高的兼容版本”。 因此，如果我们发现了Bug并发布版本0.5.1或<code>0.5.2</code>，<code>cargo</code>将自动使用最新版本，只要它仍然是<code>0.5.x</code>版本。 但是，它不会选择版本<code>0.6.0</code>，因为它不被视为兼容。 请注意，默认情况下，<code>Cargo.toml</code>中的依赖项是<code>caret</code>要求，因此相同的规则将应用于我们的引导加载程序依赖项。</p>
<p>安装bootimage工具后，创建可引导磁盘映像只需执行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> bootimage build --target x86_64-blog_os.json</span></span><br></pre></td></tr></table></figure>
<p>您会看到该工具使用<code>cargo xbuild</code>重新编译内核，所以它会自动获取您所做的任何更改。 之后它会编译引导加载程序，这可能需要一段时间。 与所有<code>crate</code>依赖项一样，它只构建一次然后会使用缓存中的内容，因此后续构建将更快。 最后，<code>bootimage</code>将引导加载程序和内核组合到可引导的磁盘映像中。</p>
<p>执行该命令后，您应在<code>target/x86_64-blog_os/debug</code>目录中看到名为<code>bootimage-blog_os.bin</code>的可引导磁盘映像。 您可以在虚拟机中启动它或将其复制到USB驱动器以在真实硬件上启动它。 （请注意，这不是CD映像，它具有不同的格式，因此将其刻录到CD不会起作用）。</p>
<h3 id="它是怎么工作的"><a href="#它是怎么工作的" class="headerlink" title="它是怎么工作的"></a>它是怎么工作的</h3><p><code>bootimage</code>工具在幕后执行了以下步骤：</p>
<ul>
<li>它将我们的内核编译为ELF文件。</li>
<li>它将引导加载程序依赖项编译为独立的可执行文件。</li>
<li>它将内核ELF文件的字节附加到引导加载程序。</li>
<li>引导时，引导加载程序读取并解析附加的ELF文件。 然后，它将程序段映射到页表中的虚拟地址，将<code>.bss</code>部分归零，并设置堆栈。 最后，它读取入口点地址（我们的<code>_start</code>函数）并跳转到它。</li>
</ul>
<h3 id="Bootimage配置"><a href="#Bootimage配置" class="headerlink" title="Bootimage配置"></a>Bootimage配置</h3><p>可以通过<code>Cargo.toml</code>文件中的<code>[package.metadata.bootimage]</code>表配置<code>bootimage</code>工具。 我们可以添加一个<code>default-target</code>选项，这样我们就不再需要传递<code>--target</code>参数：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in Cargo.toml</span></span><br><span class="line"></span><br><span class="line"><span class="section">[package.metadata.bootimage]</span></span><br><span class="line"><span class="attr">default-target</span> = <span class="string">"x86_64-blog_os.json"</span></span><br></pre></td></tr></table></figure>
<p>现在我们可以省略<code>--target</code>参数并运行<code>bootimage build</code>。</p>
<h2 id="启动！"><a href="#启动！" class="headerlink" title="启动！"></a>启动！</h2><p>我们现在可以在虚拟机中启动磁盘映像。 要在QEMU中引导它，请执行以下命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> qemu-system-x86_64 -drive format=raw,file=bootimage-blog_os.bin</span></span><br><span class="line">warning: TCG doesn't support requested feature: CPUID.01H:ECX.vmx [bit 5]</span><br></pre></td></tr></table></figure>
<p><img src="https://os.phil-opp.com/minimal-rust-kernel/qemu.png" alt="QEMU showing &quot;Hello World!&quot;"></p>
<p>或者，您可以调用bootimage工具的run子命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> bootimage run</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，它会调用与上面完全相同的QEMU命令。 在<code>--</code>之后可以传递额外的QEMU选项。 例如，<code>bootimage run -- --help</code>将显示QEMU帮助。 也可以通过<code>Cargo.toml</code>中<code>package.metadata.bootimage</code>表中的<code>run-command</code>键更改默认命令。 有关更多信息，请参阅<code>--help</code>输出或Readme。</p>
<h2 id="真机"><a href="#真机" class="headerlink" title="真机"></a>真机</h2><p>也可以将其写入USB设备并在真机上启动它：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> dd <span class="keyword">if</span>=target/x86_64-blog_os/debug/bootimage-blog_os.bin of=/dev/sdX &amp;&amp; sync</span></span><br></pre></td></tr></table></figure>
<p>其中sdX是USB设备的设备名称。 请<strong>务必注意</strong>选择正确的设备名称，因为该设备上的所有内容都会被覆盖。</p>
<h2 id="接下来？"><a href="#接下来？" class="headerlink" title="接下来？"></a>接下来？</h2><p>在下一篇文章中，我们将更详细地探索VGA文本缓冲区，并为其编写一个安全的接口。 我们还将添加对<code>println</code>宏的支持。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/Writing_an_OS_in_Rust_zh/">Home</a></li>
         
          <li><a href="/Writing_an_OS_in_Rust_zh/about/">About</a></li>
         
          <li><a href="/Writing_an_OS_in_Rust_zh/archives/">Writing</a></li>
         
          <li><a href="/Writing_an_OS_in_Rust_zh/projects_url">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#一个最小化的Rust内核"><span class="toc-number">1.</span> <span class="toc-text">一个最小化的Rust内核</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#启动过程"><span class="toc-number">1.1.</span> <span class="toc-text">启动过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#多启动标准"><span class="toc-number">1.1.1.</span> <span class="toc-text">多启动标准</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UEFI"><span class="toc-number">1.1.2.</span> <span class="toc-text">UEFI</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最小化内核"><span class="toc-number">1.2.</span> <span class="toc-text">最小化内核</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#目标定义"><span class="toc-number">1.2.1.</span> <span class="toc-text">目标定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#现在把它们放在一起"><span class="toc-number">1.2.2.</span> <span class="toc-text">现在把它们放在一起</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构建我们的内核"><span class="toc-number">1.3.</span> <span class="toc-text">构建我们的内核</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cargo-xbuild"><span class="toc-number">1.3.1.</span> <span class="toc-text">Cargo xbuild</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#输出到屏幕"><span class="toc-number">1.4.</span> <span class="toc-text">输出到屏幕</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建一个可引导的磁盘映像"><span class="toc-number">1.5.</span> <span class="toc-text">创建一个可引导的磁盘映像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#它是怎么工作的"><span class="toc-number">1.5.1.</span> <span class="toc-text">它是怎么工作的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bootimage配置"><span class="toc-number">1.5.2.</span> <span class="toc-text">Bootimage配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#启动！"><span class="toc-number">1.6.</span> <span class="toc-text">启动！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#真机"><span class="toc-number">1.7.</span> <span class="toc-text">真机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接下来？"><span class="toc-number">1.8.</span> <span class="toc-text">接下来？</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://longfangsong.github.io/2018/11/24/一个最小化的Rust内核/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://longfangsong.github.io/2018/11/24/一个最小化的Rust内核/&text=一个最小化的Rust内核"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://longfangsong.github.io/2018/11/24/一个最小化的Rust内核/&title=一个最小化的Rust内核"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://longfangsong.github.io/2018/11/24/一个最小化的Rust内核/&is_video=false&description=一个最小化的Rust内核"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=一个最小化的Rust内核&body=Check out this article: https://longfangsong.github.io/2018/11/24/一个最小化的Rust内核/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://longfangsong.github.io/2018/11/24/一个最小化的Rust内核/&title=一个最小化的Rust内核"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://longfangsong.github.io/2018/11/24/一个最小化的Rust内核/&title=一个最小化的Rust内核"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://longfangsong.github.io/2018/11/24/一个最小化的Rust内核/&title=一个最小化的Rust内核"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://longfangsong.github.io/2018/11/24/一个最小化的Rust内核/&title=一个最小化的Rust内核"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://longfangsong.github.io/2018/11/24/一个最小化的Rust内核/&name=一个最小化的Rust内核&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 Philipp Oppermann, translation into Chinese by 龙方淞
  </div>
  <!-- <div class="footer-right">
    <nav>
      <ul> -->
        <!--  
          <li><a href="/Writing_an_OS_in_Rust_zh/">Home</a></li>
         
          <li><a href="/Writing_an_OS_in_Rust_zh/about/">About</a></li>
         
          <li><a href="/Writing_an_OS_in_Rust_zh/archives/">Writing</a></li>
         
          <li><a href="/Writing_an_OS_in_Rust_zh/projects_url">Projects</a></li>
         -->
      <!-- </ul>
    </nav>
  </div> -->
</footer>

    </div>
</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/Writing_an_OS_in_Rust_zh/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/Writing_an_OS_in_Rust_zh/lib/justified-gallery/css/justifiedGallery.min.css">

<!-- jquery -->
<script src="/Writing_an_OS_in_Rust_zh/lib/jquery/jquery.min.js"></script>
<script src="/Writing_an_OS_in_Rust_zh/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/Writing_an_OS_in_Rust_zh/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


