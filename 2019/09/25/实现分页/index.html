<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="简介上一篇文章介绍了分页的概念。通过与分段进行比较，它介绍了分页，解释了分页和页表的工作原理，然后介绍了x86_64的4级页表设计。我们发现引导加载程序已经为内核建立了页表层次结构，这意味着我们的内核已经在虚拟地址上运行。由于非法内存访问会导致页面错误异常，而不是修改任意物理内存，因此可以提高安全性。 帖子的结尾是我们无法从内核访问页表的问题，因为它们存储在物理内存中，并且内核已经在虚拟地址上运行">
<meta name="keywords" content="Memory Management">
<meta property="og:type" content="article">
<meta property="og:title" content="实现分页">
<meta property="og:url" content="https://longfangsong.github.io/2019/09/25/实现分页/index.html">
<meta property="og:site_name" content="用Rust编写一个操作系统">
<meta property="og:description" content="简介上一篇文章介绍了分页的概念。通过与分段进行比较，它介绍了分页，解释了分页和页表的工作原理，然后介绍了x86_64的4级页表设计。我们发现引导加载程序已经为内核建立了页表层次结构，这意味着我们的内核已经在虚拟地址上运行。由于非法内存访问会导致页面错误异常，而不是修改任意物理内存，因此可以提高安全性。 帖子的结尾是我们无法从内核访问页表的问题，因为它们存储在物理内存中，并且内核已经在虚拟地址上运行">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://os.phil-opp.com/paging-introduction/x86_64-page-table-translation.svg">
<meta property="og:image" content="https://os.phil-opp.com/paging-implementation/identity-mapped-page-tables.svg">
<meta property="og:image" content="https://os.phil-opp.com/paging-implementation/page-tables-mapped-at-offset.svg">
<meta property="og:image" content="https://os.phil-opp.com/paging-implementation/map-complete-physical-memory.svg">
<meta property="og:image" content="https://os.phil-opp.com/paging-implementation/temporarily-mapped-page-tables.svg">
<meta property="og:image" content="https://os.phil-opp.com/paging-implementation/recursive-page-table.png">
<meta property="og:image" content="https://os.phil-opp.com/paging-implementation/recursive-page-table-access-level-1.png">
<meta property="og:image" content="https://os.phil-opp.com/paging-implementation/recursive-page-table-access-level-2.png">
<meta property="og:image" content="https://os.phil-opp.com/paging-implementation/recursive-page-table-access-level-3.png">
<meta property="og:image" content="https://d33wubrfki0l68.cloudfront.net/55d00a7a89ddaf126f40bb1414de0d78fcde09e4/478a7/paging-introduction/x86_64-table-indices-from-address.svg">
<meta property="og:image" content="https://os.phil-opp.com/advanced-paging/table-indices-from-address-recursive-level-1.svg">
<meta property="og:image" content="https://os.phil-opp.com/advanced-paging/table-indices-from-address-recursive-level-2.svg">
<meta property="og:image" content="https://os.phil-opp.com/advanced-paging/table-indices-from-address-recursive-level-3.svg">
<meta property="og:image" content="https://os.phil-opp.com/advanced-paging/table-indices-from-address-recursive-level-4.svg">
<meta property="og:image" content="https://os.phil-opp.com/paging-implementation/qemu-print-level-4-table.png">
<meta property="og:image" content="https://os.phil-opp.com/paging-implementation/qemu-translate-addr.png">
<meta property="og:image" content="https://os.phil-opp.com/paging-implementation/qemu-mapper-translate-addr.png">
<meta property="og:image" content="https://os.phil-opp.com/paging-implementation/required-page-frames-example.svg">
<meta property="og:image" content="https://os.phil-opp.com/paging-implementation/qemu-new-mapping.png">
<meta property="og:updated_time" content="2019-09-25T03:07:04.702Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="实现分页">
<meta name="twitter:description" content="简介上一篇文章介绍了分页的概念。通过与分段进行比较，它介绍了分页，解释了分页和页表的工作原理，然后介绍了x86_64的4级页表设计。我们发现引导加载程序已经为内核建立了页表层次结构，这意味着我们的内核已经在虚拟地址上运行。由于非法内存访问会导致页面错误异常，而不是修改任意物理内存，因此可以提高安全性。 帖子的结尾是我们无法从内核访问页表的问题，因为它们存储在物理内存中，并且内核已经在虚拟地址上运行">
<meta name="twitter:image" content="https://os.phil-opp.com/paging-introduction/x86_64-page-table-translation.svg">
    
    
        
          
              <link rel="shortcut icon" href="/Writing_an_OS_in_Rust_zh/images/favicon.ico">
          
        
        
          
            <link rel="icon" type="image/png" href="/Writing_an_OS_in_Rust_zh/images/favicon-192x192.png" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="/Writing_an_OS_in_Rust_zh/images/apple-touch-icon.png">
          
        
    
    <!-- title -->
    <title>实现分页</title>
    <!-- styles -->
    <link rel="stylesheet" href="/Writing_an_OS_in_Rust_zh/css/style.css">
    <!-- persian styles -->
    
      <link rel="stylesheet" href="/Writing_an_OS_in_Rust_zh/css/rtl.css">
    
    <!-- rss -->
    
    
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/Writing_an_OS_in_Rust_zh/">Home</a></li>
         
          <li><a href="/Writing_an_OS_in_Rust_zh/about/">About</a></li>
         
          <li><a href="/Writing_an_OS_in_Rust_zh/archives/">Writing</a></li>
         
          <li><a href="/Writing_an_OS_in_Rust_zh/projects_url">Projects</a></li>
        
      </ul>
    </span>
    <br>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/Writing_an_OS_in_Rust_zh/2019/02/12/CPU异常/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://longfangsong.github.io/2019/09/25/实现分页/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://longfangsong.github.io/2019/09/25/实现分页/&text=实现分页"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://longfangsong.github.io/2019/09/25/实现分页/&title=实现分页"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://longfangsong.github.io/2019/09/25/实现分页/&is_video=false&description=实现分页"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=实现分页&body=Check out this article: https://longfangsong.github.io/2019/09/25/实现分页/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://longfangsong.github.io/2019/09/25/实现分页/&title=实现分页"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://longfangsong.github.io/2019/09/25/实现分页/&title=实现分页"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://longfangsong.github.io/2019/09/25/实现分页/&title=实现分页"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://longfangsong.github.io/2019/09/25/实现分页/&title=实现分页"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://longfangsong.github.io/2019/09/25/实现分页/&name=实现分页&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#升级依赖"><span class="toc-number">1.1.</span> <span class="toc-text">升级依赖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问页表"><span class="toc-number">2.</span> <span class="toc-text">访问页表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#直接映射"><span class="toc-number">2.1.</span> <span class="toc-text">直接映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#以固定偏移量映射"><span class="toc-number">2.2.</span> <span class="toc-text">以固定偏移量映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#映射整个物理内存"><span class="toc-number">2.3.</span> <span class="toc-text">映射整个物理内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#临时映射"><span class="toc-number">2.4.</span> <span class="toc-text">临时映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归页表"><span class="toc-number">2.5.</span> <span class="toc-text">递归页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#地址计算"><span class="toc-number">2.6.</span> <span class="toc-text">地址计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Rust代码"><span class="toc-number">2.6.1.</span> <span class="toc-text">Rust代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bootloader支持"><span class="toc-number">3.</span> <span class="toc-text">Bootloader支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引导信息"><span class="toc-number">4.</span> <span class="toc-text">引导信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#entry-point宏"><span class="toc-number">4.1.</span> <span class="toc-text">entry_point宏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现"><span class="toc-number">5.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#访问页表-1"><span class="toc-number">5.1.</span> <span class="toc-text">访问页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#地址转换"><span class="toc-number">5.2.</span> <span class="toc-text">地址转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用OffsetPageTable"><span class="toc-number">5.3.</span> <span class="toc-text">使用OffsetPageTable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建一个新映射"><span class="toc-number">5.4.</span> <span class="toc-text">创建一个新映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#create-example-mapping函数"><span class="toc-number">5.4.1.</span> <span class="toc-text">create_example_mapping函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一个虚拟的FrameAllocator"><span class="toc-number">5.4.2.</span> <span class="toc-text">一个虚拟的FrameAllocator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#选择虚拟页面"><span class="toc-number">5.4.3.</span> <span class="toc-text">选择虚拟页面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建映射"><span class="toc-number">5.4.4.</span> <span class="toc-text">创建映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分配帧"><span class="toc-number">5.4.5.</span> <span class="toc-text">分配帧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#usable-frames方法"><span class="toc-number">5.4.6.</span> <span class="toc-text">usable_frames方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现-FrameAllocator-Trait"><span class="toc-number">5.4.7.</span> <span class="toc-text">实现 FrameAllocator Trait</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用BootInfoFrameAllocator"><span class="toc-number">5.4.8.</span> <span class="toc-text">使用BootInfoFrameAllocator</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接下来？"><span class="toc-number">7.</span> <span class="toc-text">接下来？</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope="" itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        实现分页
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
        <span itemprop="name">用Rust编写一个操作系统</span>
      </span>
      
    <div class="postdate">
        <time datetime="2019-09-24T23:43:38.000Z" itemprop="datePublished">2019-09-25</time>
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link" href="/Writing_an_OS_in_Rust_zh/tags/Memory-Management/">Memory Management</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>上一篇文章介绍了分页的概念。通过与分段进行比较，它介绍了分页，解释了分页和页表的工作原理，然后介绍了x86_64的4级页表设计。我们发现引导加载程序已经为内核建立了页表层次结构，这意味着我们的内核已经在虚拟地址上运行。由于非法内存访问会导致页面错误异常，而不是修改任意物理内存，因此可以提高安全性。</p>
<p>帖子的结尾是我们无法从内核访问页表的问题，因为它们存储在物理内存中，并且内核已经在虚拟地址上运行。这篇文章在这一点上继续，并探讨使页表帧可供我们的内核访问的不同方法。我们将讨论每种方法的优缺点，然后为我们的内核决定一种方法。</p>
<p>要实现此方法，我们将需要引导加载程序的支持，因此我们将首先对其进行配置。之后，我们将实现遍历页表层次结构的功能，以将虚拟地址转换为物理地址。最后，我们学习如何在页表中创建新的映射以及如何找到未使用的内存帧来创建新的页表。</p>
<h3 id="升级依赖"><a href="#升级依赖" class="headerlink" title="升级依赖"></a>升级依赖</h3><p>这篇文章需要x86_64依赖项的0.7.5版或更高版本。 您可以在Cargo.toml中更新依赖项：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">x86_64</span> = <span class="string">"0.7.5"</span></span><br></pre></td></tr></table></figure>
<p>有关最新版本中的更改的概述，请查看 <a href="https://github.com/rust-osdev/x86_64/blob/master/Changelog.md" target="_blank" rel="noopener"><code>x86_64</code>changelog</a>。</p>
<h2 id="访问页表"><a href="#访问页表" class="headerlink" title="访问页表"></a>访问页表</h2><p>从我们的内核访问页表并不像看起来那样容易。 为了理解这个问题，让我们再次看一下前一篇文章的示例4级页面表层次结构：</p>
<p><img src="https://os.phil-opp.com/paging-introduction/x86_64-page-table-translation.svg" alt="An example 4-level page hierarchy with each page table shown in physical memory"></p>
<p>这里重要的是每个页面条目都存储下一张表的物理地址。 这避免了也需要为这些地址运行转换，这将对性能造成不利影响，并很容易导致无限的转换循环。</p>
<p>对我们来说，问题在于我们无法直接从内核访问物理地址，因为我们的内核还运行在虚拟地址之上。 例如，当我们访问地址4 KiB时，我们访问的是虚拟地址4 KiB，而不是存储第4级页表的物理地址4 KiB。 当我们要访问物理地址4 KiB时，我们只能通过一些映射到它的虚拟地址来进行访问。</p>
<p>因此，为了访问页表帧，我们需要将一些虚拟页映射到它们。 创建这些映射的方法有很多，所有这些方法都允许我们访问任意页表框架。</p>
<h3 id="直接映射"><a href="#直接映射" class="headerlink" title="直接映射"></a>直接映射</h3><p>一个简单的解决方案是<strong>对所有页表进行直接映射</strong>：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/identity-mapped-page-tables.svg" alt="A virtual and a physical address space with various virtual pages mapped to the physical frame with the same address"></p>
<p>在此示例中，我们看到了一些直接映射的页表帧。这样，页表的物理地址也是有效的虚拟地址，因此我们可以轻松地从CR3寄存器访问所有级别的页表。</p>
<p>但是，它会使虚拟地址空间变得混乱，并使得找到更大尺寸的连续存储区域变得更加困难。例如，假设我们要在上面的图形中创建一个大小为1000 KiB的虚拟内存区域，例如用于<a href="https://zh.wikipedia.org/wiki/内存映射文件" target="_blank" rel="noopener">内存映射文件</a>。我们无法在<code>28 KiB</code>处开始该区域，因为它会与<code>1004KiB</code>处已映射的页面碰撞。因此，我们必须进一步寻找，直到找到足够大的未映射区域，例如<code>1008 KiB</code>。这是与分段类似的碎片问题。</p>
<p>同样，这使创建新的页表变得更加困难，因为我们需要找到其相应页尚未使用的物理帧。例如，假设我们为内存映射文件保留了从<code>1008 KiB</code>开始的虚拟1000 KiB内存区域。现在我们不能再使用物理地址在<code>1000 KiB</code>和<code>2008 KiB</code>之间的任何帧，因为我们无法对其进行直接映射。</p>
<h3 id="以固定偏移量映射"><a href="#以固定偏移量映射" class="headerlink" title="以固定偏移量映射"></a>以固定偏移量映射</h3><p>为避免虚拟地址空间混乱的问题，我们可以为<strong>页表映射使用单独的内存区域</strong>。 因此，我们将其带固定偏移量地映射到虚拟地址空间中，而不是直接映射页表框架。 例如，偏移量可以是10 TiB：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/page-tables-mapped-at-offset.svg" alt="The same figure as for the identity mapping, but each mapped virtual page is offset by 10 TiB."></p>
<p>通过将<code>10TiB..(10TiB + physical memory size)</code>范围内的虚拟内存专门用于页表映射，我们避免了直接映射的冲突问题。 仅当虚拟地址空间远大于物理内存大小时，才可以保留虚拟地址空间的较大区域。 在x86_64上这不是问题，因为48位地址空间为256 TiB。</p>
<p>这种方法仍然有一个缺点，那就是每当我们创建一个新的页表时我们都需要创建一个新的映射。 另外，它不允许访问其他地址空间的页表，这在创建新进程时很有用。</p>
<h3 id="映射整个物理内存"><a href="#映射整个物理内存" class="headerlink" title="映射整个物理内存"></a>映射整个物理内存</h3><p>我们可以通过映射完整的物理内存而不是仅映射页表框架来解决这些问题：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/map-complete-physical-memory.svg" alt="The same figure as for the offset mapping, but every physical frame has a mapping (at 10TiB + X) instead of only page table frames."></p>
<p>这种方法允许我们的内核访问任意物理内存，包括其他地址空间的页表帧。 保留的虚拟内存范围具有与以前相同的大小，不同之处在于它不再包含未映射的页面。</p>
<p>这种方法的缺点是需要额外的页表来存储物理内存的映射。 这些页表需要存储在某个地方，因此它们会占用一部分物理内存，这在内存量较小的设备上可能会成为问题。</p>
<p>但是，在x86_64上，我们可以使用大小为2MiB的大页面进行映射，而不是使用默认的4KiB页面。 这样，由于只需要一个3级表和32个2级表，映射32 GiB物理内存仅需要132 KiB用于页表。 大型页面还可以提高缓存效率，因为它们在转译后备缓冲器（TLB）中使用的条目更少。</p>
<h3 id="临时映射"><a href="#临时映射" class="headerlink" title="临时映射"></a>临时映射</h3><p>对于物理内存量很小的设备，我们只能在需要访问它们时才<strong>临时映射页表帧</strong>。 为了能够创建临时映射，我们只需要一个直接映射的1级页表：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/temporarily-mapped-page-tables.svg" alt="A virtual and a physical address space with an identity mapped level 1 table, which maps its 0th entry to the level 2 table frame, thereby mapping that frame to page with address 0"></p>
<p>此图中的1级表控制虚拟地址空间的前2MiB。这是因为它可以通过从CR3寄存器开始，沿着4级，3级和2级页表中的第0个条目来最终访问到。索引为8的条目将地址32 KiB的虚拟页映射到地址<code>32 KiB</code>的物理帧，从而标识了1级页表本身。该图通过32 KiB处的水平箭头显示了此身份映射。</p>
<p>通过写入直接映射的1级页表，我们的内核最多可以创建511个临时映射（512减去标识映射所需的条目）。在上面的示例中，内核创建了两个临时映射：</p>
<ul>
<li>通过将第1级表的第0个条目映射到地址为<code>24 KiB</code>的帧，它创建了从<code>0 KiB</code>处的虚拟页到第2级页表的物理帧的临时映射，如虚线箭头所示。</li>
<li>通过将1级表的第9个条目映射到地址为<code>4 KiB</code>的帧，它创建了一个虚拟映射，将<code>36 KiB</code>处的虚拟页临时映射到4级页表的物理帧，如虚线箭头所示。</li>
</ul>
<p>现在内核可以通过写入<code>0 KiB</code>处的页面来访问2级页面表，并通过写入<code>36 KiB</code>处的页面来访问4级页面表。</p>
<p>使用临时映射访问任意页表框架的过程将是：</p>
<ul>
<li>在标识映射的级别1表中搜索空闲条目。</li>
<li>将该条目映射到我们要访问的页表的物理帧。</li>
<li>通过映射到条目的虚拟页面访问目标帧。</li>
<li>将条目设置回未使用状态，从而删除临时映射。</li>
</ul>
<p>这种方法重复使用相同的512个虚拟页来创建映射，因此仅需要4KiB的物理内存。缺点是它有点麻烦，特别是因为新映射可能需要修改多个表级别，这意味着我们将需要重复上述过程多次。</p>
<h3 id="递归页表"><a href="#递归页表" class="headerlink" title="递归页表"></a>递归页表</h3><p>另一个根本不需要其他页表的有趣方法是递归映射页表。 这种方法背后的想法是将4级页面表的某些条目映射到4级表本身。 通过这样做，我们有效地保留了虚拟地址空间的一部分，并将所有当前和将来的页表框架映射到该空间。</p>
<p>让我们通过一个例子来理解这一切是如何工作的：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/recursive-page-table.png" alt="An example 4-level page hierarchy with each page table shown in physical memory. Entry 511 of the level 4 page is mapped to frame 4KiB, the frame of the level 4 table itself."></p>
<p>与本文开头示例的唯一区别是，级别4表中索引<code>511</code>处的附加条目被映射到级别4表本身的帧<code>4 KiB</code>。</p>
<p>通过让CPU在翻译中跟踪此条目，它不会到达3级表，而又到达同一4级表。这类似于调用自身的递归函数，因此此表称为递归页表。重要的是，CPU假定4级表中的每个条目都指向3级表，因此现在将4级表视为3级表。这是可行的，因为所有级别的表在x86_64上的布局都完全相同。</p>
<p>通过在开始实际转换之前跟踪递归项一次或多次，我们可以有效地缩短CPU遍历的级别数。例如，如果我们只跟踪一次递归条目，然后进入3级表，则CPU认为3级表是2级表。更进一步，它将2级表视为1级表，1级表视为映射的帧。这意味着我们现在可以读写1级页表，因为CPU认为它是映射的帧。下图说明了5个翻译步骤：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/recursive-page-table-access-level-1.png" alt="The above example 4-level page hierarchy with 5 arrows: &quot;Step 0&quot; from CR4 to level 4 table, &quot;Step 1&quot; from level 4 table to level 4 table, &quot;Step 2&quot; from level 4 table to level 3 table, &quot;Step 3&quot; from level 3 table to level 2 table, and &quot;Step 4&quot; from level 2 table to level 1 table."></p>
<p>同样，在开始翻译之前，我们可以两次跟踪递归项，以将遍历级别的数量减少到两个：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/recursive-page-table-access-level-2.png" alt="The same 4-level page hierarchy with the following 4 arrows: &quot;Step 0&quot; from CR4 to level 4 table, &quot;Steps 1&amp;2&quot; from level 4 table to level 4 table, &quot;Step 3&quot; from level 4 table to level 3 table, and &quot;Step 4&quot; from level 3 table to level 2 table."></p>
<p>让我们一步步看：首先，CPU跟踪4级表上的递归条目，并认为它已到达3级表。然后，它再次遵循递归条目，并认为它到达了2级表。但实际上，它仍然位于4级表中。现在，CPU跟着另一个条目进入时，它将降落在3级表上，但认为它已经在1级表上。因此，当下一个条目指向2级表时，CPU认为它指向映射的帧，这使我们可以读写2级表。</p>
<p>访问3级和4级表的工作方式相同。为了访问3级表，我们遵循了3次递归条目，使CPU认为它已经在1级表中。然后，我们跟随另一个条目并到达第3级表，CPU将其视为映射帧。要访问4级表本身，我们只需遵循递归项四次，直到CPU将4级表本身视为映射帧（下图中的蓝色）。</p>
<p><img src="https://os.phil-opp.com/paging-implementation/recursive-page-table-access-level-3.png" alt="The same 4-level page hierarchy with the following 3 arrows: &quot;Step 0&quot; from CR4 to level 4 table, &quot;Steps 1,2,3&quot; from level 4 table to level 4 table, and &quot;Step 4&quot; from level 4 table to level 3 table. In blue the alternative &quot;Steps 1,2,3,4&quot; arrow from level 4 table to level 4 table."></p>
<h3 id="地址计算"><a href="#地址计算" class="headerlink" title="地址计算"></a>地址计算</h3><p>我们看到我们可以通过在实际翻译之前递归一次或多次来访问所有级别的表。 由于四个级别的表中的索引直接来自虚拟地址，因此我们需要为此技术构建特殊的虚拟地址。 请记住，页表索引是通过以下方式从地址中得到的：</p>
<p><img src="https://d33wubrfki0l68.cloudfront.net/55d00a7a89ddaf126f40bb1414de0d78fcde09e4/478a7/paging-introduction/x86_64-table-indices-from-address.svg" alt="Bits 0–12 are the page offset, bits 12–21 the level 1 index, bits 21–30 the level 2 index, bits 30–39 the level 3 index, and bits 39–48 the level 4 index"></p>
<p>假设我们想要访问映射特定页面的1级页表。 如上所述，这意味着在继续使用4级，3级和2级索引之前，我们必须递归一次。 为此，我们将地址的每个块向右移动一个块，并将原始的4级索引设置为递归条目的索引：</p>
<p><img src="https://os.phil-opp.com/advanced-paging/table-indices-from-address-recursive-level-1.svg" alt="Bits 0–12 are the offset into the level 1 table frame, bits 12–21 the level 2 index, bits 21–30 the level 3 index, bits 30–39 the level 4 index, and bits 39–48 the index of the recursive entry"></p>
<p>为了访问该页面的2级页表，我们将每个索引块向右移动两个块，并将原来的4级索引和原来的3级索引的块都设置为递归条目的索引：</p>
<p><img src="https://os.phil-opp.com/advanced-paging/table-indices-from-address-recursive-level-2.svg" alt="Bits 0–12 are the offset into the level 2 table frame, bits 12–21 the level 3 index, bits 21–30 the level 4 index, and bits 30–39 and bits 39–48 are the index of the recursive entry"></p>
<p>访问3级表的方法是将每个块向右移动三个块，并使用原来的4级，3级和2级地址块的递归索引：</p>
<p><img src="https://os.phil-opp.com/advanced-paging/table-indices-from-address-recursive-level-3.svg" alt="Bits 0–12 are the offset into the level 3 table frame, bits 12–21 the level 4 index, and bits 21–30, bits 30–39 and bits 39–48 are the index of the recursive entry"></p>
<p>最后，我们可以通过向右移动每个块四个块并使用除偏移之外的所有地址块的递归索引来访问4级表：</p>
<p><img src="https://os.phil-opp.com/advanced-paging/table-indices-from-address-recursive-level-4.svg" alt="Bits 0–12 are the offset into the level l table frame and bits 12–21, bits 21–30, bits 30–39 and bits 39–48 are the index of the recursive entry"></p>
<p>我们现在可以计算所有四个级别的页表的虚拟地址。 我们甚至可以通过将其索引乘以8（页表条目的大小）来计算精确指向特定页表条目的地址。</p>
<p>下表总结了访问不同类型帧的地址结构：</p>
<table>
<thead>
<tr>
<th></th>
<th>虚拟地址的结构(八进制)</th>
</tr>
</thead>
<tbody>
<tr>
<td>页</td>
<td><code>0o_SSSSSS_AAA_BBB_CCC_DDD_EEEE</code></td>
</tr>
<tr>
<td>1级页表项</td>
<td><code>0o_SSSSSS_RRR_AAA_BBB_CCC_DDDD</code></td>
</tr>
<tr>
<td>2级页表项</td>
<td><code>0o_SSSSSS_RRR_RRR_AAA_BBB_CCCC</code></td>
</tr>
<tr>
<td>3级页表项</td>
<td><code>0o_SSSSSS_RRR_RRR_RRR_AAA_BBBB</code></td>
</tr>
<tr>
<td>4级页表项</td>
<td><code>0o_SSSSSS_RRR_RRR_RRR_RRR_AAAA</code></td>
</tr>
</tbody>
</table>
<p><code>AAA</code>是4级索引，<code>BBB</code>是3级索引，<code>CCC</code>是2级索引，<code>DDD</code>是映射帧的1级索引，而<code>EEEE</code>是偏移量。 <code>RRR</code>是递归条目的索引。 当索引（三位数）转换为偏移量（四位数）时，通过将其乘以8（页面表条目的大小）来完成。使用此偏移量，结果地址直接指向相应的页表条目。</p>
<p><code>SSSSSS</code>是符号扩展位，这意味着它们都是第47位的副本。这是x86_64体系结构上对有效地址的特殊要求。 我们在上一篇文章中解释过它。</p>
<p>我们使用八进制数来表示地址，因为每个八进制字符代表三位，这使我们能够清楚地分离不同页表级别的9位索引。 对于每个字符代表四位的十六进制系统，这是不可能的。</p>
<h4 id="Rust代码"><a href="#Rust代码" class="headerlink" title="Rust代码"></a>Rust代码</h4><p>要在Rust代码中构造这样的地址，可以使用按位操作：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the virtual address whose corresponding page tables you want to access</span></span><br><span class="line"><span class="keyword">let</span> addr: <span class="built_in">usize</span> = […];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> r = <span class="number">0o777</span>; <span class="comment">// recursive index</span></span><br><span class="line"><span class="keyword">let</span> sign = <span class="number">0o177777</span> &lt;&lt; <span class="number">48</span>; <span class="comment">// sign extension</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// retrieve the page table indices of the address that we want to translate</span></span><br><span class="line"><span class="keyword">let</span> l4_idx = (addr &gt;&gt; <span class="number">39</span>) &amp; <span class="number">0o777</span>; <span class="comment">// level 4 index</span></span><br><span class="line"><span class="keyword">let</span> l3_idx = (addr &gt;&gt; <span class="number">30</span>) &amp; <span class="number">0o777</span>; <span class="comment">// level 3 index</span></span><br><span class="line"><span class="keyword">let</span> l2_idx = (addr &gt;&gt; <span class="number">21</span>) &amp; <span class="number">0o777</span>; <span class="comment">// level 2 index</span></span><br><span class="line"><span class="keyword">let</span> l1_idx = (addr &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0o777</span>; <span class="comment">// level 1 index</span></span><br><span class="line"><span class="keyword">let</span> page_offset = addr &amp; <span class="number">0o7777</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculate the table addresses</span></span><br><span class="line"><span class="keyword">let</span> level_4_table_addr =</span><br><span class="line">    sign | (r &lt;&lt; <span class="number">39</span>) | (r &lt;&lt; <span class="number">30</span>) | (r &lt;&lt; <span class="number">21</span>) | (r &lt;&lt; <span class="number">12</span>);</span><br><span class="line"><span class="keyword">let</span> level_3_table_addr =</span><br><span class="line">    sign | (r &lt;&lt; <span class="number">39</span>) | (r &lt;&lt; <span class="number">30</span>) | (r &lt;&lt; <span class="number">21</span>) | (l4_idx &lt;&lt; <span class="number">12</span>);</span><br><span class="line"><span class="keyword">let</span> level_2_table_addr =</span><br><span class="line">    sign | (r &lt;&lt; <span class="number">39</span>) | (r &lt;&lt; <span class="number">30</span>) | (l4_idx &lt;&lt; <span class="number">21</span>) | (l3_idx &lt;&lt; <span class="number">12</span>);</span><br><span class="line"><span class="keyword">let</span> level_1_table_addr =</span><br><span class="line">    sign | (r &lt;&lt; <span class="number">39</span>) | (l4_idx &lt;&lt; <span class="number">30</span>) | (l3_idx &lt;&lt; <span class="number">21</span>) | (l2_idx &lt;&lt; <span class="number">12</span>);</span><br></pre></td></tr></table></figure>
<p>上面的代码假定索引为<code>0o777</code>（511）的最后一个4级条目被递归映射。 目前情况并非如此，因此代码尚无法使用。 请参阅下文，了解如何告诉引导加载程序设置递归映射。</p>
<p>除了手动执行按位运算，还可以使用<code>x86_64</code> crate的<a href="https://docs.rs/x86_64/0.7.5/x86_64/structures/paging/mapper/struct.RecursivePageTable.html" target="_blank" rel="noopener"><code>RecursivePageTable</code></a>类型，该类型为各种页表操作提供安全的抽象。 例如，以下代码显示了如何将虚拟地址转换为其映射的物理地址：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in src/memory.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> x86_64::structures::paging::&#123;Mapper, Page, PageTable, RecursivePageTable&#125;;</span><br><span class="line"><span class="keyword">use</span> x86_64::&#123;VirtAddr, PhysAddr&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Creates a RecursivePageTable instance from the level 4 address.</span></span><br><span class="line"><span class="keyword">let</span> level_4_table_addr = […];</span><br><span class="line"><span class="keyword">let</span> level_4_table_ptr = level_4_table_addr <span class="keyword">as</span> *<span class="keyword">mut</span> PageTable;</span><br><span class="line"><span class="keyword">let</span> recursive_page_table = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> level_4_table = &amp;<span class="keyword">mut</span> *level_4_table_ptr;</span><br><span class="line">    RecursivePageTable::new(level_4_table).unwrap();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Retrieve the physical address for the given virtual address</span></span><br><span class="line"><span class="keyword">let</span> addr: <span class="built_in">u64</span> = […]</span><br><span class="line"><span class="keyword">let</span> addr = VirtAddr::new(addr);</span><br><span class="line"><span class="keyword">let</span> page: Page = Page::containing_address(addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// perform the translation</span></span><br><span class="line"><span class="keyword">let</span> frame = recursive_page_table.translate_page(page);</span><br><span class="line">frame.map(|frame| frame.start_address() + <span class="built_in">u64</span>::from(addr.page_offset()))</span><br></pre></td></tr></table></figure>
<p>同样，此代码需要有效的递归映射。 使用这种映射，可以像第一个代码示例中那样计算<code>level_4_table_addr</code>。</p>
<p>递归分页是一种有趣的技术，它可以显示页表中单个映射的功能。 它相对容易实现，只需要最少的设置（只需一个递归项），因此它是第一个分页实验的不错选择。</p>
<p>但是，它也有一些缺点：</p>
<ul>
<li>它占用大量虚拟内存（512GiB）。 在较大的48位地址空间中，这不是一个大问题，但它可能导致不太好的缓存表现。</li>
<li>它仅允许轻松访问当前活动的地址空间。 通过更改递归项仍然可以访问其他地址空间，但是需要临时映射才能切换回去。 我们在（过时的）“<a href="https://os.phil-opp.com/remap-the-kernel/#overview" target="_blank" rel="noopener">重新映射内核</a>”一文中描述了如何执行此操作。<br>它</li>
<li>在很大程度上依赖于x86的页表格式，可能无法在其他体系结构上使用。</li>
</ul>
<h2 id="Bootloader支持"><a href="#Bootloader支持" class="headerlink" title="Bootloader支持"></a>Bootloader支持</h2><p>所有这些方法都需要对其页表进行修改以进行设置。例如，需要创建物理内存的映射，或者需要递归映射4级表的条目。问题在于，如果没有现有的访问页表的方法，我们将无法创建这些必需的映射。</p>
<p>这意味着我们需要引导加载程序的帮助，该程序会创建内核运行的页表。引导加载程序有权访问页表，因此它可以创建我们需要的任何映射。在当前的实现中，<code>bootloader</code> crate支持上述两种方法，并通过cargo fratures进行控制：</p>
<ul>
<li><code>map_physical_memory</code>功能将整个物理内存映射到虚拟地址空间中的某个位置。因此，内核可以访问所有物理内存，并且可以遵循“映射完整物理内存”方法。</li>
<li>借助<code>recursive_page_table</code>功能，引导加载程序将递归映射4级页面表的条目。这允许内核按照“递归页面表”部分中的描述访问页面表。</li>
</ul>
<p>我们为内核选择第一种方法，因为它简单，独立于平台且功能更强大（它还允许访问非页表框架）。为了启用所需的引导程序支持，我们将<code>map_physical_memory</code>功能添加到了引导程序依赖项中：</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">bootloader</span> = &#123; version = <span class="string">"0.8.0"</span>, features = [<span class="string">"map_physical_memory"</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>启用此功能后，引导加载程序会将完整的物理内存映射到一些未使用的虚拟地址范围。 为了将虚拟地址范围传达给我们的内核，引导加载程序会传递引导信息结构。</p>
<h2 id="引导信息"><a href="#引导信息" class="headerlink" title="引导信息"></a>引导信息</h2><p><code>bootloader</code> crate定义了一个<a href="https://docs.rs/bootloader/0.3.11/bootloader/bootinfo/struct.BootInfo.html" target="_blank" rel="noopener"><code>BootInfo</code></a>结构，该结构包含传递给我们内核的所有信息。该结构仍处于早期阶段，因此在更新为将来与semver不兼容的引导加载程序版本时，可能会有些破损。启用<code>map_physical_memory</code>功能后，它当前具有两个字段<code>memory_map</code>和<code>physical_memory_offset</code>：</p>
<ul>
<li><code>memory_map</code>字段包含可用物理内存的概述。这告诉我们内核系统中有多少可用物理内存，以及哪些内存区域为VGA硬件等设备保留。可以从BIOS或UEFI固件查询内存映射，但是只能在启动过程的早期进行查询。出于这个原因，它必须由引导加载程序提供，因为内核无法在以后检索它。在本文的后面，我们将需要内存映射。</li>
<li><code>physical_memory_offset</code>告诉我们物理内存映射的虚拟起始地址。通过将此偏移量添加到物理地址，我们可以获得相应的虚拟地址。这使我们可以从内核访问任意物理内存。</li>
</ul>
<p>引导加载程序以_start函数的＆’static BootInfo参数的形式将BootInfo结构传递给我们的内核。我们尚未在函数中声明此参数，因此让我们添加一下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in src/main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> bootloader::BootInfo;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[no_mangle]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">fn</span> <span class="title">_start</span></span>(boot_info: &amp;<span class="symbol">'static</span> BootInfo) -&gt; ! &#123; <span class="comment">// new argument</span></span><br><span class="line">    […]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在此之前我们不此参数不是问题，因为x86_64调用约定在CPU寄存器中传递了第一个参数。 因此，如果不声明参数，则只会忽略该参数。 但是，如果我们不小心使用了错误的参数类型，那将是一个问题，因为编译器不知道我们入口点函数的正确类型签名。</p>
<h3 id="entry-point宏"><a href="#entry-point宏" class="headerlink" title="entry_point宏"></a><code>entry_point</code>宏</h3><p>由于<code>_start</code>函数是从引导加载程序外部调用的，因此不会检查函数签名。 这意味着我们可以让它接受任意参数而没有任何编译错误，但是它将失败或在运行时导致未定义的行为。</p>
<p>为了确保入口点函数始终具有引导程序期望的正确签名，<code>bootloader</code> crate提供了<code>entry_point</code>宏，该宏提供了类型检查的方式来将Rust函数定义为入口点。 让我们重写我们的入口点函数以使用此宏：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in src/main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> bootloader::&#123;BootInfo, entry_point&#125;;</span><br><span class="line"></span><br><span class="line">entry_point!(kernel_main);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">kernel_main</span></span>(boot_info: &amp;<span class="symbol">'static</span> BootInfo) -&gt; ! &#123;</span><br><span class="line">    […]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们不再需要在我们的入口点上使用<code>extern &quot;C&quot;</code>或<code>no_mangle</code>，因为该宏为我们定义了真正的下层<code>_start</code>入口点。 现在，<code>kernel_main</code>函数是一个完全正常的Rust函数，因此我们可以为其选择任意名称。 重要的是对它进行类型检查，以便在我们使用错误的函数签名时（例如通过添加参数或更改参数类型）发生编译错误。</p>
<p>让我们在<code>lib.rs</code>中执行相同的更改：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in src/lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">use</span> bootloader::&#123;entry_point, BootInfo&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line">entry_point!(test_kernel_main);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Entry point for `cargo xtest`</span></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test_kernel_main</span></span>(_boot_info: &amp;<span class="symbol">'static</span> BootInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="comment">// like before</span></span><br><span class="line">    init();</span><br><span class="line">    test_main();</span><br><span class="line">    hlt_loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于入口点仅在测试模式下使用，因此我们将<code>＃[cfg(test)]</code>属性添加到所有项。 我们为测试入口点指定不同的名称<code>test_kernel_main</code>，以避免与main.rs的<code>kernel_main</code>混淆。 我们暂时不使用<code>BootInfo</code>参数，因此我们在参数名称前添加<code>_</code>以禁用”未使用的变量”警告。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>现在，我们可以访问物理内存了，我们终于可以开始实现页面表代码了。 首先，我们来看看运行内核的当前活动页表。 在第二步中，我们将创建一个转换函数，该函数返回给定虚拟地址映射到的物理地址。 作为最后一步，我们将尝试修改页表以创建新的映射。</p>
<p>在开始之前，我们为代码创建一个新的内存模块：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in src/lib.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> memory;</span><br></pre></td></tr></table></figure>
<h3 id="访问页表-1"><a href="#访问页表-1" class="headerlink" title="访问页表"></a>访问页表</h3><p>在上一篇文章的末尾，我们试图查看内核运行的页表，但是由于无法访问CR3寄存器指向的物理帧而失败。 现在，我们可以通过创建一个<code>active_level_4_table</code>函数来返回对活动4级页面表的引用，从而继续：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in src/memory.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> x86_64::&#123;</span><br><span class="line">    structures::paging::PageTable,</span><br><span class="line">    VirtAddr,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Returns a mutable reference to the active level 4 table.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This function is unsafe because the caller must guarantee that the</span></span><br><span class="line"><span class="comment">/// complete physical memory is mapped to virtual memory at the passed</span></span><br><span class="line"><span class="comment">/// `physical_memory_offset`. Also, this function must be only called once</span></span><br><span class="line"><span class="comment">/// to avoid aliasing `&amp;mut` references (which is undefined behavior).</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">active_level_4_table</span></span>(physical_memory_offset: VirtAddr)</span><br><span class="line">    -&gt; &amp;<span class="symbol">'static</span> <span class="keyword">mut</span> PageTable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">use</span> x86_64::registers::control::Cr3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (level_4_table_frame, _) = Cr3::read();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> phys = level_4_table_frame.start_address();</span><br><span class="line">    <span class="keyword">let</span> virt = physical_memory_offset + phys.as_u64();</span><br><span class="line">    <span class="keyword">let</span> page_table_ptr: *<span class="keyword">mut</span> PageTable = virt.as_mut_ptr();</span><br><span class="line"></span><br><span class="line">    &amp;<span class="keyword">mut</span> *page_table_ptr <span class="comment">// unsafe</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们从CR3寄存器中读取活动的4级表的物理帧。 然后，我们获取其物理起始地址，将其转换为u64，并将其添加到<code>physical_memory_offset</code>中，以获取页面表框架所映射的虚拟地址。 最后，我们通过<code>as_mut_ptr</code>方法将虚拟地址转换为<code>*mut PageTable</code>原始指针，然后从中安全地创建<code>＆mut PageTable</code>引用。 我们创建一个<code>＆mut</code>引用而不是<code>＆</code>引用，因为我们将在本文后面的页面表中进行改变。</p>
<p>我们在这里不需要使用unsafe块，因为Rust将不安全的fn的整个像一个大的不安全的块一样对待。 这使我们的代码更加危险，因为我们可能在不注意的情况下意外引入了不安全的操作。 这也使发现不安全操作变得更加困难。 有一个RFC希望可以更改此行为。</p>
<p>现在，我们可以使用此功能来打印4级表的条目：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in src/main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">kernel_main</span></span>(boot_info: &amp;<span class="symbol">'static</span> BootInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">use</span> blog_os::memory::active_level_4_table;</span><br><span class="line">    <span class="keyword">use</span> x86_64::VirtAddr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello World&#123;&#125;"</span>, <span class="string">"!"</span>);</span><br><span class="line">    blog_os::init();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> phys_mem_offset = VirtAddr::new(boot_info.physical_memory_offset);</span><br><span class="line">    <span class="keyword">let</span> l4_table = <span class="keyword">unsafe</span> &#123; active_level_4_table(phys_mem_offset) &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i, entry) <span class="keyword">in</span> l4_table.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> !entry.is_unused() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"L4 Entry &#123;&#125;: &#123;:?&#125;"</span>, i, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// as before</span></span><br><span class="line">    <span class="meta">#[cfg(test)]</span></span><br><span class="line">    test_main();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"It did not crash!"</span>);</span><br><span class="line">    blog_os::hlt_loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，我们将<code>BootInfo</code>结构的<code>physical_memory_offset</code>转换为<code>VirtAddr</code>，并将其传递给<code>active_level_4_table</code>函数。 然后，我们使用<code>iter</code>函数对页表条目进行迭代，并使用<code>enumerate</code>组合子为每个元素添加索引<code>i</code>。 我们仅打印非空条目，因为所有512个条目均无法显示在屏幕上。</p>
<p>运行它时，我们看到以下输出：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/qemu-print-level-4-table.png" alt="QEMU printing entry 0 (0x2000, PRESENT, WRITABLE, ACCESSED), entry 1 (0x894000, PRESENT, WRITABLE, ACCESSED, DIRTY), entry 31 (0x88e000, PRESENT, WRITABLE, ACCESSED, DIRTY), entry 175 (0x891000, PRESENT, WRITABLE, ACCESSED, DIRTY), and entry 504 (0x897000, PRESENT, WRITABLE, ACCESSED, DIRTY)"></p>
<p>我们看到有各种非空条目，它们都映射到不同的3级表。 区域太多了，因为内核代码，内核堆栈，物理内存映射和引导信息都使用单独的内存区域。</p>
<p>为了进一步遍历页表并查看3级表，我们可以将一个条目的映射到的帧再次转换为虚拟地址：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in the `for` loop in src/main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> x86_64::structures::paging::PageTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !entry.is_unused() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"L4 Entry &#123;&#125;: &#123;:?&#125;"</span>, i, entry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get the physical address from the entry and convert it</span></span><br><span class="line">    <span class="keyword">let</span> phys = entry.frame().unwrap().start_address();</span><br><span class="line">    <span class="keyword">let</span> virt = phys.as_u64() + boot_info.physical_memory_offset;</span><br><span class="line">    <span class="keyword">let</span> ptr = VirtAddr::new(virt).as_mut_ptr();</span><br><span class="line">    <span class="keyword">let</span> l3_table: &amp;PageTable = <span class="keyword">unsafe</span> &#123; &amp;*ptr &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print non-empty entries of the level 3 table</span></span><br><span class="line">    <span class="keyword">for</span> (i, entry) <span class="keyword">in</span> l3_table.iter().enumerate() &#123;</span><br><span class="line">        <span class="keyword">if</span> !entry.is_unused() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"  L3 Entry &#123;&#125;: &#123;:?&#125;"</span>, i, entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了查看2级和1级表，我们对3级和2级条目重复该过程。 您可以想象，这很快就会变得非常冗长，因此我们在这里不显示完整的代码。</p>
<p>手动遍历页表很有趣，因为它有助于了解CPU如何执行转换。 但是，大多数时候我们只对给定虚拟地址的映射物理地址感兴趣，因此让我们为其创建一个函数。</p>
<h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h3><p>为了将虚拟地址转换为物理地址，我们必须遍历四级页表，直到到达映射的帧。 让我们创建一个执行此转换的函数：</p>
<p>为了将虚拟地址转换为物理地址，我们必须遍历四级页表，直到到达映射的帧。 让我们创建一个执行此转换的函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in src/memory.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> x86_64::PhysAddr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Translates the given virtual address to the mapped physical address, or</span></span><br><span class="line"><span class="comment">/// `None` if the address is not mapped.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This function is unsafe because the caller must guarantee that the</span></span><br><span class="line"><span class="comment">/// complete physical memory is mapped to virtual memory at the passed</span></span><br><span class="line"><span class="comment">/// `physical_memory_offset`.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">translate_addr</span></span>(addr: VirtAddr, physical_memory_offset: VirtAddr)</span><br><span class="line">    -&gt; <span class="built_in">Option</span>&lt;PhysAddr&gt;</span><br><span class="line">&#123;</span><br><span class="line">    translate_addr_inner(addr, physical_memory_offset)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将该函数转发给安全的<code>translate_addr_inner</code>函数，以限制不安全的范围。 如上所述，Rust将unsafe fn的整个主体视为一个大的unsafe块。 通过调用私有safe函数，我们使每个unsafe操作再次明确。</p>
<p>内部私有函数包含实际的实现：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in src/memory.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// Private function that is called by `translate_addr`.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This function is safe to limit the scope of `unsafe` because Rust treats</span></span><br><span class="line"><span class="comment">/// the whole body of unsafe functions as an unsafe block. This function must</span></span><br><span class="line"><span class="comment">/// only be reachable through `unsafe fn` from outside of this module.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">translate_addr_inner</span></span>(addr: VirtAddr, physical_memory_offset: VirtAddr)</span><br><span class="line">    -&gt; <span class="built_in">Option</span>&lt;PhysAddr&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">use</span> x86_64::structures::paging::page_table::FrameError;</span><br><span class="line">    <span class="keyword">use</span> x86_64::registers::control::Cr3;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the active level 4 frame from the CR3 register</span></span><br><span class="line">    <span class="keyword">let</span> (level_4_table_frame, _) = Cr3::read();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> table_indexes = [</span><br><span class="line">        addr.p4_index(), addr.p3_index(), addr.p2_index(), addr.p1_index()</span><br><span class="line">    ];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> frame = level_4_table_frame;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// traverse the multi-level page table</span></span><br><span class="line">    <span class="keyword">for</span> &amp;index <span class="keyword">in</span> &amp;table_indexes &#123;</span><br><span class="line">        <span class="comment">// convert the frame into a page table reference</span></span><br><span class="line">        <span class="keyword">let</span> virt = physical_memory_offset + frame.start_address().as_u64();</span><br><span class="line">        <span class="keyword">let</span> table_ptr: *<span class="keyword">const</span> PageTable = virt.as_ptr();</span><br><span class="line">        <span class="keyword">let</span> table = <span class="keyword">unsafe</span> &#123;&amp;*table_ptr&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// read the page table entry and update `frame`</span></span><br><span class="line">        <span class="keyword">let</span> entry = &amp;table[index];</span><br><span class="line">        frame = <span class="keyword">match</span> entry.frame() &#123;</span><br><span class="line">            <span class="literal">Ok</span>(frame) =&gt; frame,</span><br><span class="line">            <span class="literal">Err</span>(FrameError::FrameNotPresent) =&gt; <span class="keyword">return</span> <span class="literal">None</span>,</span><br><span class="line">            <span class="literal">Err</span>(FrameError::HugeFrame) =&gt; <span class="built_in">panic!</span>(<span class="string">"huge pages not supported"</span>),</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate the physical address by adding the page offset</span></span><br><span class="line">    <span class="literal">Some</span>(frame.start_address() + <span class="built_in">u64</span>::from(addr.page_offset()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们不再重用我们的<code>active_level_4_table</code>函数，而是再次从<code>CR3</code>寄存器读取4级帧。我们这样做是因为它简化了此原型的实现。不用担心，我们稍后会创建一个更好的解决方案。</p>
<p><code>VirtAddr</code>结构已经提供了将索引计算到四个级别的页表中的方法。我们将这些索引存储在一个小的数组中，因为它允许我们使用for循环遍历页表。在循环之外，我们记得最后访问的帧，以便稍后计算物理地址。该框架在迭代时指向页表框架，并在最后一次迭代后（即在跟随1级条目之后）指向映射的框架。</p>
<p>在循环内部，我们再次使用<code>physical_memory_offset</code>将帧转换为页表引用。 然后，我们读取当前页表的条目，并使用<code>PageTableEntry::frame</code>函数检索映射的帧。 如果条目未映射到帧，则返回<code>None</code>。 如果条目映射了一个<code>2MiB</code>或<code>1GiB</code>的huge页面，我们现在会panic。</p>
<p>让我们通过翻译一些地址来测试我们的翻译功能：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in src/main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">kernel_main</span></span>(boot_info: &amp;<span class="symbol">'static</span> BootInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="comment">// new imports</span></span><br><span class="line">    <span class="keyword">use</span> blog_os::memory::translate_addr;</span><br><span class="line">    <span class="keyword">use</span> x86_64::VirtAddr;</span><br><span class="line"></span><br><span class="line">    […] <span class="comment">// hello world and blog_os::init</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> phys_mem_offset = VirtAddr::new(boot_info.physical_memory_offset);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> addresses = [</span><br><span class="line">        <span class="comment">// the identity-mapped vga buffer page</span></span><br><span class="line">        <span class="number">0xb8000</span>,</span><br><span class="line">        <span class="comment">// some code page</span></span><br><span class="line">        <span class="number">0x201008</span>,</span><br><span class="line">        <span class="comment">// some stack page</span></span><br><span class="line">        <span class="number">0x0100_0020_1a10</span>,</span><br><span class="line">        <span class="comment">// virtual address mapped to physical address 0</span></span><br><span class="line">        boot_info.physical_memory_offset,</span><br><span class="line">    ];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;address <span class="keyword">in</span> &amp;addresses &#123;</span><br><span class="line">        <span class="keyword">let</span> virt = VirtAddr::new(address);</span><br><span class="line">        <span class="keyword">let</span> phys = <span class="keyword">unsafe</span> &#123; translate_addr(virt, phys_mem_offset) &#125;;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125; -&gt; &#123;:?&#125;"</span>, virt, phys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    […] <span class="comment">// test_main(), "it did not crash" printing, and hlt_loop()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跑一下看看，我们可以看到如下输出：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/qemu-translate-addr.png" alt="0xb8000 -&gt; 0xb8000, 0x201008 -&gt; 0x401008, 0x10000201a10 -&gt; 0x279a10, &quot;panicked at &#39;huge pages not supported&#39;"></p>
<p>如预期的那样，直接映射的地址<code>0xb8000</code>转换为相同的物理地址。代码页和堆栈页转换为一些任意的物理地址，这取决于引导加载程序如何为内核创建初始映射。值得注意的是，转换后的最后12位始终保持不变，这是有道理的，因为这些位是页面偏移量，而不是转换的一部分。</p>
<p>由于可以通过添加<code>physical_memory_offset</code>来访问每个物理地址，因此<code>physical_memory_offset</code>地址本身的转换应指向物理地址0。但是，转换失败了，因为该映射使用huge页面来提高效率，这在我们的实现中尚不支持。</p>
<h3 id="使用OffsetPageTable"><a href="#使用OffsetPageTable" class="headerlink" title="使用OffsetPageTable"></a>使用<code>OffsetPageTable</code></h3><p>将虚拟地址转换为物理地址是OS内核中的常见任务，因此<code>x86_64</code> crate为其提供了抽象。该实现已经支持huge 页面和除<code>translate_addr</code>之外的其他几个页面表功能，因此我们将在下面使用它，而不是向我们自己的实现添加huge页面支持。</p>
<p>抽象的基础是定义各种页表映射功能的两个trait：</p>
<ul>
<li><code>Mapper</code> trait在页面大小上是通用的，并提供可在页面上运行的功能。例如：<code>translate_page</code>（将给定页面转换为相同大小的框架）和map_to（在页面表中创建新的映射）。</li>
<li><code>MapperAllSizes</code>特性意味着实现者为所有页面大小实现Mapper。此外，它提供了适用于多种页面大小的功能，例如<code>translate_addr</code>或常规的<code>translate</code>。</li>
</ul>
<p>trait仅定义接口，它们不提供任何实现。当前，<code>x86_64</code> crate提供了三种类型，这些类型可实现具有不同要求的特征。 <code>OffsetPageTable</code>类型假定完整的物理内存以某个偏移量映射到虚拟地址空间。 <code>MappedPageTable</code>稍微灵活一些：它只需要将每个页表帧映射到可计算地址处的虚拟地址空间即可。最后，可以使用<code>RecursivePageTable</code>类型通过递归页表访问页表框架。</p>
<p>在我们的例子中，引导加载程序将完整的物理内存映射到由<code>physical_memory_offset</code>变量指定的虚拟地址，因此我们可以使用<code>OffsetPageTable</code>类型。要初始化它，我们在内存模块中创建一个新的<code>init</code>函数：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> x86_64::structures::paging::OffsetPageTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Initialize a new OffsetPageTable.</span></span><br><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="comment">/// This function is unsafe because the caller must guarantee that the</span></span><br><span class="line"><span class="comment">/// complete physical memory is mapped to virtual memory at the passed</span></span><br><span class="line"><span class="comment">/// `physical_memory_offset`. Also, this function must be only called once</span></span><br><span class="line"><span class="comment">/// to avoid aliasing `&amp;mut` references (which is undefined behavior).</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>(physical_memory_offset: VirtAddr) -&gt; OffsetPageTable&lt;<span class="symbol">'static</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> level_4_table = active_level_4_table(physical_memory_offset);</span><br><span class="line">    OffsetPageTable::new(level_4_table, physical_memory_offset)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// make private</span></span><br><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">active_level_4_table</span></span>(physical_memory_offset: VirtAddr)</span><br><span class="line">    -&gt; &amp;<span class="symbol">'static</span> <span class="keyword">mut</span> PageTable</span><br><span class="line">&#123;…&#125;</span><br></pre></td></tr></table></figure>
<p>该函数将<code>physical_memory_offset</code>作为参数，并返回一个具有<code>&#39;static</code>生命周期的新<code>OffsetPageTable</code>实例。这意味着实例对于我们的内核的完整运行时保持有效。在函数主体中，我们首先调用<code>active_level_4_table</code>函数以检索对第4级页表的可变引用。然后，我们使用此引用调用<code>OffsetPageTable::new</code>函数。作为第二个参数，新函数期望在物理内存的映射处开始的虚拟地址，该地址在<code>physical_memory_offset</code>变量中给出。</p>
<p>从现在开始，仅应从<code>init</code>函数调用<code>active_level_4_table</code>函数，因为当多次调用它时，它很容易使用可变的引用，这可能导致未定义的行为。因此，我们通过删除<code>pub</code>说明符来使函数私有。</p>
<p>现在，我们可以使用<code>MapperAllSizes::translate_addr</code>方法来代替我们自己的<code>memory::translate_addr</code>函数。我们只需要在<code>kernel_main</code>中更改几行：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in src/main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">kernel_main</span></span>(boot_info: &amp;<span class="symbol">'static</span> BootInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="comment">// new: different imports</span></span><br><span class="line">    <span class="keyword">use</span> blog_os::memory;</span><br><span class="line">    <span class="keyword">use</span> x86_64::&#123;structures::paging::MapperAllSizes, VirtAddr&#125;;</span><br><span class="line"></span><br><span class="line">    […] <span class="comment">// hello world and blog_os::init</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> phys_mem_offset = VirtAddr::new(boot_info.physical_memory_offset);</span><br><span class="line">    <span class="comment">// new: initialize a mapper</span></span><br><span class="line">    <span class="keyword">let</span> mapper = <span class="keyword">unsafe</span> &#123; memory::init(phys_mem_offset) &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> addresses = […]; <span class="comment">// same as before</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;address <span class="keyword">in</span> &amp;addresses &#123;</span><br><span class="line">        <span class="keyword">let</span> virt = VirtAddr::new(address);</span><br><span class="line">        <span class="comment">// new: use the `mapper.translate_addr` method</span></span><br><span class="line">        <span class="keyword">let</span> phys = mapper.translate_addr(virt);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125; -&gt; &#123;:?&#125;"</span>, virt, phys);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    […] <span class="comment">// test_main(), "it did not crash" printing, and hlt_loop()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要导入<code>MapperAllSizes</code>trait以使用它提供的<code>translate_addr</code>方法。</p>
<p>现在运行它时，我们会看到与以前相同的翻译结果，不同之处在于huge页面翻译现在也可以工作：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/qemu-mapper-translate-addr.png" alt="0xb8000 -&gt; 0xb8000, 0x201008 -&gt; 0x401008, 0x10000201a10 -&gt; 0x279a10, 0x18000000000 -&gt; 0x0"></p>
<p>不出所料，<code>0xb8000</code>的转换以及代码和堆栈地址与我们自己的转换功能相同。 此外，我们现在看到虚拟地址<code>physical_memory_offset</code>映射到物理地址<code>0x0</code>。</p>
<p>通过使用<code>MappedPageTable</code>类型的转换功能，我们可以节省实施大型页面支持的工作。 我们还可以访问其他页面功能，例如<code>map_to</code>，我们将在下一部分中使用。</p>
<p>此时，我们不再需要<code>memory::translate_addr</code>函数，因此可以将其删除。</p>
<h3 id="创建一个新映射"><a href="#创建一个新映射" class="headerlink" title="创建一个新映射"></a>创建一个新映射</h3><p>到目前为止，我们仅查看页面表，而没有进行任何修改。让我们通过为以前未映射的页面创建一个新的映射来更改它。</p>
<p>我们将使用<code>Mapper</code> trait 的<code>map_to</code>函数进行实现，因此让我们首先看一下该函数。文档告诉我们，它带有四个参数：我们要映射的页面，该页面应映射到的框架，页面表项的一组标志以及<code>frame_allocator</code>。我们需要一个帧分配器，因为映射给定页面可能需要创建其他页面表，这些页面表需要未使用的帧作为后备存储。</p>
<h4 id="create-example-mapping函数"><a href="#create-example-mapping函数" class="headerlink" title="create_example_mapping函数"></a><code>create_example_mapping</code>函数</h4><p>我们实现的第一步是创建一个新的<code>create_example_mapping</code>函数，该函数将给定的虚拟页面映射到<code>0xb8000</code>（VGA文本缓冲区的物理帧）。我们选择该帧是因为它使我们能够轻松测试映射是否正确创建：我们只需要向新映射的页面写入，然后查看是否看到写入内容出现在屏幕上。</p>
<p><code>create_example_mapping</code>函数如下所示：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in src/memory.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> x86_64::&#123;</span><br><span class="line">    PhysAddr,</span><br><span class="line">    structures::paging::&#123;Page, PhysFrame, Mapper, Size4KiB, FrameAllocator&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Creates an example mapping for the given page to frame `0xb8000`.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">create_example_mapping</span></span>(</span><br><span class="line">    page: Page,</span><br><span class="line">    mapper: &amp;<span class="keyword">mut</span> OffsetPageTable,</span><br><span class="line">    frame_allocator: &amp;<span class="keyword">mut</span> <span class="keyword">impl</span> FrameAllocator&lt;Size4KiB&gt;,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">use</span> x86_64::structures::paging::PageTableFlags <span class="keyword">as</span> Flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> frame = PhysFrame::containing_address(PhysAddr::new(<span class="number">0xb8000</span>));</span><br><span class="line">    <span class="keyword">let</span> flags = Flags::PRESENT | Flags::WRITABLE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> map_to_result = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        mapper.map_to(page, frame, flags, frame_allocator)</span><br><span class="line">    &#125;;</span><br><span class="line">    map_to_result.expect(<span class="string">"map_to failed"</span>).flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了应该映射的<code>page</code>之外，该函数还需要一个对<code>OffsetPageTable</code>实例的可变引用，和一个<code>frame_allocator</code>。 <code>frame_allocator</code>参数对实现了<code>FrameAllocator</code> trait 的所有类型通用。该特征在<code>PageSize</code> trait上具有通用性，可与标准4KiB页面和huge的2MiB/1GiB页面一起使用。我们只想创建4KiB映射，因此我们将通用参数设置为<code>Size4KiB</code>。</p>
<p>对于映射，我们设置<code>PRESENT</code>标志是因为所有有效条目都需要它，而<code>WRITABLE</code>标志则使映射的页面可写。调用<code>map_to</code>是不安全的，因为有可能使用无效的参数来破坏内存安全性，因此我们需要使用一个<code>unsafe</code>块。有关所有可能的标志的列表，请参见上一篇文章的“页面表格式”部分。</p>
<p><code>map_to</code>函数可能会失败，因此它将返回<code>Result</code>。由于这只是一些示例代码，不需要鲁棒性，因此我们仅在发生错误时使用<code>expect</code>来引发一个panic。成功后，该函数将返回MapperFlush类型，该类型提供了一种使用其flush方法从转换后备缓冲区（TLB）中刷新新映射页面的简便方法。像<code>Result</code>一样，当我们意外忘记使用它时，由于使用了<code>#[must_use]</code>属性，会发出一个警告。</p>
<h4 id="一个虚拟的FrameAllocator"><a href="#一个虚拟的FrameAllocator" class="headerlink" title="一个虚拟的FrameAllocator"></a>一个虚拟的FrameAllocator</h4><p>为了能够调用<code>create_example_mapping</code>，我们需要创建一个首先实现<code>FrameAllocator</code> Trait的类型。如上所述，如果<code>map_to</code>需要帧，则Trait负责为新页表分配帧。</p>
<p>让我们从简单的案例开始，并假设我们不需要创建新的页表。对于这种情况，始终返回<code>None</code>的帧分配器就足够了。我们创建了一个<code>EmptyFrameAllocator</code>来测试我们的映射功能：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in src/memory.rs</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// A FrameAllocator that always returns `None`.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">EmptyFrameAllocator</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> FrameAllocator&lt;Size4KiB&gt; <span class="keyword">for</span> EmptyFrameAllocator &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">allocate_frame</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;PhysFrame&gt; &#123;</span><br><span class="line">        <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现<code>FrameAllocator</code>是unsafe的，因为实现者必须保证分配器仅产生未使用的帧。 否则，可能会发生不确定的行为，例如，当两个虚拟页面映射到同一物理框架时。 我们的<code>EmptyFrameAllocator</code>只返回<code>None</code>，因此在这种情况下这不是问题。</p>
<h4 id="选择虚拟页面"><a href="#选择虚拟页面" class="headerlink" title="选择虚拟页面"></a>选择虚拟页面</h4><p>现在，我们有了一个简单的帧分配器，可以将其传递给<code>create_example_mapping</code>函数。 但是，分配器始终返回<code>None</code>，因此只有在不需要其他页表框架来创建映射时，此分配器才起作用。 要了解何时需要其他页表框架以及何时不需要，请考虑以下示例：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/required-page-frames-example.svg" alt="A virtual and a physical address space with a single mapped page and the page tables of all four levels"></p>
<p>该图在左侧显示虚拟地址空间，在右侧显示物理地址空间，以及它们之间的页表。页表存储在物理存储帧中，由虚线表示。虚拟地址空间在地址<code>0x803fe00000</code>包含一个映射的页面，该页面以蓝色标记。为了将此页面转换为其框架，CPU遍历4级页面表，直到到达地址36 KiB的框架。</p>
<p>此外，该图以红色显示VGA文本缓冲区的物理帧。我们的目标是使用我们的<code>create_example_mapping</code>函数将先前未映射的虚拟页面映射到此帧。由于<code>EmptyFrameAllocator</code>始终返回<code>None</code>，因此我们要创建映射，以便不需要分配器中的其他帧。这取决于我们为映射选择的虚拟页面。</p>
<p>该图显示了虚拟地址空间中的两个候选页面，均以黄色标记。一页位于地址<code>0x803fdfd000</code>，即映射页之前的3页（蓝色）。尽管第4级和第3级页表索引与蓝页相同，但第2级和第1级索引却不同（请参阅上一篇文章）。级别2表中的索引不同，意味着此页面使用了不同的级别1表。由于此1级表尚不存在，因此如果我们为示例映射选择该页面，则需要创建该表，这将需要一个额外的未使用的物理框架。相反，位于地址<code>0x803fe02000</code>的第二个候选页面不存在此问题，因为它使用与蓝色页面相同的1级页面表。因此，所有必需的页表已经存在。</p>
<p>总而言之，创建新映射的难度取决于我们要映射的虚拟页面。在最简单的情况下，该页面的1级页面表已经存在，我们只需要编写一个条目即可。在最困难的情况下，该页面位于尚不存在第3级的内存区域中，因此我们需要首先创建新的第3级，第2级和第1级页表。</p>
<p>为了使用<code>EmptyFrameAllocator</code>调用<code>create_example_mapping</code>函数，我们需要选择一个页面，其所有页表均已存在。要找到这样的页面，我们可以利用引导加载程序将自身加载到虚拟地址空间的第一个兆字节中这一事实。这意味着该区域的所有页面都存在一个有效的1级表。因此，我们可以为示例映射选择该存储区域中任何未使用的页面，例如地址0的页面。通常，该页面应保持未使用状态，以确保取消引用空指针会导致页面错误，因此我们知道引导加载程序保持了该页面的未映射状态。</p>
<h4 id="创建映射"><a href="#创建映射" class="headerlink" title="创建映射"></a>创建映射</h4><p>现在，我们有了用于调用<code>create_example_mapping</code>函数的所有必需参数，因此让我们修改<code>kernel_main</code>函数，以将页面映射到虚拟地址0。由于我们将页面映射到VGA文本缓冲区的帧，因此我们应该能够向屏幕写入。实现看起来像这样：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in src/main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">kernel_main</span></span>(boot_info: &amp;<span class="symbol">'static</span> BootInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">use</span> blog_os::memory;</span><br><span class="line">    <span class="keyword">use</span> x86_64::&#123;structures::paging::Page, VirtAddr&#125;; <span class="comment">// new import</span></span><br><span class="line"></span><br><span class="line">    […] <span class="comment">// hello world and blog_os::init</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> phys_mem_offset = VirtAddr::new(boot_info.physical_memory_offset);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> mapper = <span class="keyword">unsafe</span> &#123; memory::init(phys_mem_offset) &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> frame_allocator = memory::EmptyFrameAllocator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map an unused page</span></span><br><span class="line">    <span class="keyword">let</span> page = Page::containing_address(VirtAddr::new(<span class="number">0</span>));</span><br><span class="line">    memory::create_example_mapping(page, &amp;<span class="keyword">mut</span> mapper, &amp;<span class="keyword">mut</span> frame_allocator);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// write the string `New!` to the screen through the new mapping</span></span><br><span class="line">    <span class="keyword">let</span> page_ptr: *<span class="keyword">mut</span> <span class="built_in">u64</span> = page.start_address().as_mut_ptr();</span><br><span class="line">    <span class="keyword">unsafe</span> &#123; page_ptr.offset(<span class="number">400</span>).write_volatile(<span class="number">0x_f021_f077_f065_f04e</span>)&#125;;</span><br><span class="line"></span><br><span class="line">    […] <span class="comment">// test_main(), "it did not crash" printing, and hlt_loop()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先通过调用<code>create_example_mapping</code>函数来调用地址0处的页面的映射。 这会将页面映射到VGA文本缓冲区框架，因此我们应该在屏幕上看到对其进行的任何写入。</p>
<p>然后，我们将页面转换为原始指针，并向偏移量400写入一个值。我们不写入页面的开头，因为VGA缓冲区的第一行直接由下一个println移出屏幕。 我们写入值<code>0x_f021_f077_f065_f04e</code>，它表示字符串“ New！”。 在白色背景上。 正如我们在“ VGA Text Mode”（VGA文本模式）文章中所了解的那样，对VGA缓冲区的写入应该是易失的，因此我们使用<code>write_volatile</code>方法。</p>
<p>在QEMU中运行它时，将看到以下输出：</p>
<p><img src="https://os.phil-opp.com/paging-implementation/qemu-new-mapping.png" alt="QEMU printing &quot;It did not crash!&quot; with four completely white cells in the middle of the screen"></p>
<p>屏幕上的 “New!” 是通过写入第<code>0</code>页来显示的，这意味着我们已在页表中成功创建了新映射。</p>
<p>仅因为负责地址0的页面的1级表已经存在，所以创建该映射才起作用。 当我们尝试为尚不存在1级表的页面进行映射时，<code>map_to</code>函数将失败，因为它试图从<code>EmptyFrameAllocator</code>分配帧以创建新的页表。 当我们尝试映射页面<code>0xdeadbeaf000</code>而不是<code>0</code>时，我们可以看到这种情况：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in src/main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">kernel_main</span></span>(boot_info: &amp;<span class="symbol">'static</span> BootInfo) -&gt; ! &#123;</span><br><span class="line">    […]</span><br><span class="line">    <span class="keyword">let</span> page = Page::containing_address(VirtAddr::new(<span class="number">0xdeadbeaf000</span>));</span><br><span class="line">    […]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们运行它时，会出现以下错误消息：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panicked at <span class="symbol">'map_to</span> failed: FrameAllocationFailed', /…/result.rs:<span class="number">999</span>:<span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>要映射没有1级页面表的页面，我们需要创建一个适当的<code>FrameAllocator</code>。 但是我们如何知道哪些帧未使用以及有多少物理内存可用？</p>
<h4 id="分配帧"><a href="#分配帧" class="headerlink" title="分配帧"></a>分配帧</h4><p>为了创建新的页表，我们需要创建一个适当帧分配器。 为此，我们使用由引导程序作为<code>BootInfo</code>结构的一部分传递的<code>memory_map</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in src/memory.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> bootloader::bootinfo::MemoryMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A FrameAllocator that returns usable frames from the bootloader's memory map.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">BootInfoFrameAllocator</span></span> &#123;</span><br><span class="line">    memory_map: &amp;<span class="symbol">'static</span> MemoryMap,</span><br><span class="line">    next: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> BootInfoFrameAllocator &#123;</span><br><span class="line">    <span class="comment">/// Create a FrameAllocator from the passed memory map.</span></span><br><span class="line">    <span class="comment">///</span></span><br><span class="line">    <span class="comment">/// This function is unsafe because the caller must guarantee that the passed</span></span><br><span class="line">    <span class="comment">/// memory map is valid. The main requirement is that all frames that are marked</span></span><br><span class="line">    <span class="comment">/// as `USABLE` in it are really unused.</span></span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">init</span></span>(memory_map: &amp;<span class="symbol">'static</span> MemoryMap) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        BootInfoFrameAllocator &#123;</span><br><span class="line">            memory_map,</span><br><span class="line">            next: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该结构有两个字段：对引导加载程序传递的内存映射的<code>&#39;static</code>引用，以及一个跟踪分配器应返回的下一帧的编号的<code>next</code>字段。</p>
<p>如我们在“引导信息”部分所述，内存映射由BIOS / UEFI固件提供。它只能在引导过程的早期被查询，因此引导加载程序已经为我们调用了相应的函数。存储器映射由<code>MemoryRegion</code>结构的列表组成，这些结构包含每个存储器区域的起始地址，长度和类型（例如未使用，保留等）。</p>
<p>初始化函数使用给定的内存映射初始化<code>BootInfoFrameAllocator</code>。下一个字段用0初始化，并且将在每次帧分配时递增，以避免两次返回同一帧。由于我们不知道内存映射的可用帧是否已在其他地方使用，因此我们的<code>init</code>函数必须unsafe才能要求调用者提供其他保证。</p>
<h4 id="usable-frames方法"><a href="#usable-frames方法" class="headerlink" title="usable_frames方法"></a><code>usable_frames</code>方法</h4><p>在实现<code>FrameAllocator</code>特性之前，我们添加了一个辅助方法，该方法将内存映射转换为可用帧的迭代器：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in src/memory.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> bootloader::bootinfo::MemoryRegionType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> BootInfoFrameAllocator &#123;</span><br><span class="line">    <span class="comment">/// Returns an iterator over the usable frames specified in the memory map.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">usable_frames</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="keyword">impl</span> <span class="built_in">Iterator</span>&lt;Item = PhysFrame&gt; &#123;</span><br><span class="line">        <span class="comment">// get usable regions from memory map</span></span><br><span class="line">        <span class="keyword">let</span> regions = <span class="keyword">self</span>.memory_map.iter();</span><br><span class="line">        <span class="keyword">let</span> usable_regions = regions</span><br><span class="line">            .filter(|r| r.region_type == MemoryRegionType::Usable);</span><br><span class="line">        <span class="comment">// map each region to its address range</span></span><br><span class="line">        <span class="keyword">let</span> addr_ranges = usable_regions</span><br><span class="line">            .map(|r| r.range.start_addr()..r.range.end_addr());</span><br><span class="line">        <span class="comment">// transform to an iterator of frame start addresses</span></span><br><span class="line">        <span class="keyword">let</span> frame_addresses = addr_ranges.flat_map(|r| r.step_by(<span class="number">4096</span>));</span><br><span class="line">        <span class="comment">// create `PhysFrame` types from the start addresses</span></span><br><span class="line">        frame_addresses</span><br><span class="line">            .map(|addr|PhysFrame::containing_address(PhysAddr::new(addr)))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数使用迭代器组合子方法将初始<code>MemoryMap</code>转换为可用物理帧的迭代器：</p>
<ul>
<li>首先，我们调用<code>ite</code>r方法将内存映射转换为MemoryRegions的迭代器。</li>
<li>然后，我们使用<code>filter</code>方法跳过任何保留的区域或其他不可用的区域。引导加载程序会为其创建的所有映射更新内存映射，因此内核使用的帧（代码，数据或堆栈）或用于存储引导信息的帧已被标记为InUse或类似的。因此，我们可以确定可用框架不会在其他地方使用。</li>
<li>之后，我们使用<code>map</code>组合子和Rust的range语法将内存区域的迭代器转换为地址范围的迭代器。</li>
<li>下一步是最复杂的：我们通过<code>into_iter</code>方法将每个范围转换为一个迭代器，然后使用<code>step_by</code>选择每个范围内的第4096个地址。由于页面大小为4096字节（= 4 KiB），因此我们获得了每个帧的起始地址。 Bootloader页面会对齐所有可用的内存区域，因此我们在此处不需要任何对齐或舍入代码。通过使用<code>flat_map</code>而不是<code>map</code>，我们得到了<code>Iterator &lt;Item = u64&gt;</code>而不是<code>Iterator &lt;Item = Iterator &lt;Item = u64 &gt;&gt;</code>。</li>
<li>最后，我们将起始地址转换为<code>PhysFrame</code>类型，以构造所需的<code>Iterator &lt;Item = PhysFrame&gt;</code>。然后，我们使用此迭代器创建并返回一个新的<code>BootInfoFrameAllocator</code>。<br>该函数的返回类型使用<code>impl Trait</code>功能。这样，我们可以指定返回某种类型为<code>PhysFrame</code>的实现<code>Iterator</code>trait的类型，而无需命名具体的返回类型。这一点很重要，因为我们无法命名具体类型，因为它取决于不可命名的闭包类型。</li>
</ul>
<h4 id="实现-FrameAllocator-Trait"><a href="#实现-FrameAllocator-Trait" class="headerlink" title="实现 FrameAllocator Trait"></a>实现 <code>FrameAllocator</code> Trait</h4><p>现在我们可以实现<code>FrameAllocator</code> trait：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in src/memory.rs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> FrameAllocator&lt;Size4KiB&gt; <span class="keyword">for</span> BootInfoFrameAllocator &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">allocate_frame</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;PhysFrame&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> frame = <span class="keyword">self</span>.usable_frames().nth(<span class="keyword">self</span>.next);</span><br><span class="line">        <span class="keyword">self</span>.next += <span class="number">1</span>;</span><br><span class="line">        frame</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先使用<code>usable_frames</code>方法从内存映射中获取可用帧的迭代器。 然后，我们使用<code>Iterator::nth</code>函数获取索引为<code>self.next</code>的帧（从而跳过<code>(self.next-1)</code>帧）。 在返回该帧之前，我们将<code>self.next</code>增加一，以便在下一次调用时返回下一个帧。</p>
<p>这种实现方式并不是十分理想，因为它会在每次分配时重新创建<code>usable_frame</code>分配器。 最好直接将迭代器存储为<code>struct</code>字段。 然后，我们将不需要<code>nth</code>方法，而只需对每个分配调用<code>next</code>。 这种方法的问题在于，当前无法在<code>struct</code>字段中存储<code>impl Trait</code>类型。完全实现<a href="https://github.com/rust-lang/rfcs/pull/2071" target="_blank" rel="noopener">具名存在性类型</a>的某天，这个方法可能可以使用。</p>
<h4 id="使用BootInfoFrameAllocator"><a href="#使用BootInfoFrameAllocator" class="headerlink" title="使用BootInfoFrameAllocator"></a>使用<code>BootInfoFrameAllocator</code></h4><p>现在，我们可以修改<code>kernel_main</code>函数，以传递<code>BootInfoFrameAllocator</code>实例而不是<code>EmptyFrameAllocator</code>：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in src/main.rs</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">kernel_main</span></span>(boot_info: &amp;<span class="symbol">'static</span> BootInfo) -&gt; ! &#123;</span><br><span class="line">    <span class="keyword">use</span> blog_os::memory::BootInfoFrameAllocator;</span><br><span class="line">    […]</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> frame_allocator = <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        BootInfoFrameAllocator::init(&amp;boot_info.memory_map)</span><br><span class="line">    &#125;;</span><br><span class="line">    […]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用引导信息帧分配器，映射成功了，并且我们看到了黑白“ New！” 再次出现在屏幕上。 在后台，<code>map_to</code>方法通过以下方式创建缺少的页表：</p>
<ul>
<li>从传递的<code>frame_allocator</code>中分配未使用的帧。</li>
<li>将帧内容全部设置为0以创建一个新的空页表。</li>
<li>将更高级别的表的条目映射到该框架。</li>
<li>继续下一个表格级别。</li>
</ul>
<p>尽管我们的<code>create_example_mapping</code>函数只是一些示例代码，但我们现在能够为任意页面创建新的映射。 这对于在以后的帖子中分配内存或实现多线程至关重要。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在这篇文章中，我们了解了访问页表物理帧的各种技术，包括直接映射，完整物理内存的映射，临时映射和递归页表。 我们选择映射完整的物理内存，因为它简单，可移植且功能强大。</p>
<p>没有页表访问权限，我们无法映射内核中的物理内存，因此我们需要引导加载程序的支持。 引导加载程序板条箱支持通过可选的货物功能创建所需的映射。 它将所需信息以<code>&amp;BootInfo</code>参数的形式传递给我们的内核，该参数传递给我们的入口点函数。</p>
<p>对于我们的实现，我们首先手动遍历页表以实现转换功能，然后使用<code>x86_64</code>crate 的<code>MappedPageTable</code>类型。 我们还学习了如何在页表中创建新的映射，以及如何在引导加载程序传递的内存映射之上创建必要的<code>FrameAllocator</code>。</p>
<h2 id="接下来？"><a href="#接下来？" class="headerlink" title="接下来？"></a>接下来？</h2><p>下一篇文章将为我们的内核创建一个堆内存区域，这将使我们能够分配内存并使用各种集合类型。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/Writing_an_OS_in_Rust_zh/">Home</a></li>
         
          <li><a href="/Writing_an_OS_in_Rust_zh/about/">About</a></li>
         
          <li><a href="/Writing_an_OS_in_Rust_zh/archives/">Writing</a></li>
         
          <li><a href="/Writing_an_OS_in_Rust_zh/projects_url">Projects</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#升级依赖"><span class="toc-number">1.1.</span> <span class="toc-text">升级依赖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问页表"><span class="toc-number">2.</span> <span class="toc-text">访问页表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#直接映射"><span class="toc-number">2.1.</span> <span class="toc-text">直接映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#以固定偏移量映射"><span class="toc-number">2.2.</span> <span class="toc-text">以固定偏移量映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#映射整个物理内存"><span class="toc-number">2.3.</span> <span class="toc-text">映射整个物理内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#临时映射"><span class="toc-number">2.4.</span> <span class="toc-text">临时映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#递归页表"><span class="toc-number">2.5.</span> <span class="toc-text">递归页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#地址计算"><span class="toc-number">2.6.</span> <span class="toc-text">地址计算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Rust代码"><span class="toc-number">2.6.1.</span> <span class="toc-text">Rust代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bootloader支持"><span class="toc-number">3.</span> <span class="toc-text">Bootloader支持</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引导信息"><span class="toc-number">4.</span> <span class="toc-text">引导信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#entry-point宏"><span class="toc-number">4.1.</span> <span class="toc-text">entry_point宏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现"><span class="toc-number">5.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#访问页表-1"><span class="toc-number">5.1.</span> <span class="toc-text">访问页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#地址转换"><span class="toc-number">5.2.</span> <span class="toc-text">地址转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用OffsetPageTable"><span class="toc-number">5.3.</span> <span class="toc-text">使用OffsetPageTable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建一个新映射"><span class="toc-number">5.4.</span> <span class="toc-text">创建一个新映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#create-example-mapping函数"><span class="toc-number">5.4.1.</span> <span class="toc-text">create_example_mapping函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一个虚拟的FrameAllocator"><span class="toc-number">5.4.2.</span> <span class="toc-text">一个虚拟的FrameAllocator</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#选择虚拟页面"><span class="toc-number">5.4.3.</span> <span class="toc-text">选择虚拟页面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建映射"><span class="toc-number">5.4.4.</span> <span class="toc-text">创建映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分配帧"><span class="toc-number">5.4.5.</span> <span class="toc-text">分配帧</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#usable-frames方法"><span class="toc-number">5.4.6.</span> <span class="toc-text">usable_frames方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现-FrameAllocator-Trait"><span class="toc-number">5.4.7.</span> <span class="toc-text">实现 FrameAllocator Trait</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用BootInfoFrameAllocator"><span class="toc-number">5.4.8.</span> <span class="toc-text">使用BootInfoFrameAllocator</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接下来？"><span class="toc-number">7.</span> <span class="toc-text">接下来？</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" href="http://www.facebook.com/sharer.php?u=https://longfangsong.github.io/2019/09/25/实现分页/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://twitter.com/share?url=https://longfangsong.github.io/2019/09/25/实现分页/&text=实现分页"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.linkedin.com/shareArticle?url=https://longfangsong.github.io/2019/09/25/实现分页/&title=实现分页"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://pinterest.com/pin/create/bookmarklet/?url=https://longfangsong.github.io/2019/09/25/实现分页/&is_video=false&description=实现分页"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=实现分页&body=Check out this article: https://longfangsong.github.io/2019/09/25/实现分页/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="https://getpocket.com/save?url=https://longfangsong.github.io/2019/09/25/实现分页/&title=实现分页"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://reddit.com/submit?url=https://longfangsong.github.io/2019/09/25/实现分页/&title=实现分页"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.stumbleupon.com/submit?url=https://longfangsong.github.io/2019/09/25/实现分页/&title=实现分页"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://digg.com/submit?url=https://longfangsong.github.io/2019/09/25/实现分页/&title=实现分页"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="http://www.tumblr.com/share/link?url=https://longfangsong.github.io/2019/09/25/实现分页/&name=实现分页&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy; 2019 Philipp Oppermann, translation into Chinese by 龙方淞
  </div>
  <!-- <div class="footer-right">
    <nav>
      <ul> -->
        <!--  
          <li><a href="/Writing_an_OS_in_Rust_zh/">Home</a></li>
         
          <li><a href="/Writing_an_OS_in_Rust_zh/about/">About</a></li>
         
          <li><a href="/Writing_an_OS_in_Rust_zh/archives/">Writing</a></li>
         
          <li><a href="/Writing_an_OS_in_Rust_zh/projects_url">Projects</a></li>
         -->
      <!-- </ul>
    </nav>
  </div> -->
</footer>

    </div>
</body>
</html>
<!-- styles -->
<link rel="stylesheet" href="/Writing_an_OS_in_Rust_zh/lib/font-awesome/css/all.min.css">
<link rel="stylesheet" href="/Writing_an_OS_in_Rust_zh/lib/justified-gallery/css/justifiedGallery.min.css">

<!-- jquery -->
<script src="/Writing_an_OS_in_Rust_zh/lib/jquery/jquery.min.js"></script>
<script src="/Writing_an_OS_in_Rust_zh/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>
<script src="/Writing_an_OS_in_Rust_zh/js/main.js"></script>
<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Disqus Comments -->


